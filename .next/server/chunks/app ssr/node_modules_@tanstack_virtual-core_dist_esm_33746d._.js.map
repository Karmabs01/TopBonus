{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@tanstack/virtual-core/dist/esm/utils.js"],"sourcesContent":["function memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  return () => {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  };\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\nexport {\n  approxEqual,\n  debounce,\n  memo,\n  notUndefined\n};\n//# sourceMappingURL=utils.js.map\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,KAAK,OAAO,EAAE,EAAE,EAAE,IAAI;IAC7B,IAAI,OAAO,KAAK,WAAW,IAAI,EAAE;IACjC,IAAI;IACJ,OAAO;QACL,IAAI,IAAI,IAAI,IAAI;QAChB,IAAI;QACJ,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,KAAK,KAAK,KAAK,KAAK,OAAO,KAAK,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG,UAAU,KAAK,GAAG;QACxF,MAAM,UAAU;QAChB,MAAM,cAAc,QAAQ,MAAM,KAAK,KAAK,MAAM,IAAI,QAAQ,IAAI,CAAC,CAAC,KAAK,QAAU,IAAI,CAAC,MAAM,KAAK;QACnG,IAAI,CAAC,aAAa;YAChB,OAAO;QACT;QACA,OAAO;QACP,IAAI;QACJ,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,KAAK,KAAK,KAAK,KAAK,OAAO,KAAK,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG,aAAa,KAAK,GAAG;QAC3F,SAAS,MAAM;QACf,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,KAAK,KAAK,KAAK,KAAK,OAAO,KAAK,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG;YACpE,MAAM,aAAa,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,OAAO,IAAI,OAAO;YAC9D,MAAM,gBAAgB,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,UAAU,IAAI,OAAO;YACpE,MAAM,sBAAsB,gBAAgB;YAC5C,MAAM,MAAM,CAAC,KAAK;gBAChB,MAAM,OAAO;gBACb,MAAO,IAAI,MAAM,GAAG,IAAK;oBACvB,MAAM,MAAM;gBACd;gBACA,OAAO;YACT;YACA,QAAQ,IAAI,CACV,CAAC,IAAI,EAAE,IAAI,eAAe,GAAG,EAAE,EAAE,IAAI,YAAY,GAAG,GAAG,CAAC,EACxD,CAAC;;;uBAGc,EAAE,KAAK,GAAG,CACvB,GACA,KAAK,GAAG,CAAC,MAAM,MAAM,qBAAqB,MAC1C,cAAc,CAAC,EACjB,QAAQ,OAAO,KAAK,IAAI,KAAK,GAAG;QAEpC;QACA,CAAC,KAAK,QAAQ,OAAO,KAAK,IAAI,KAAK,QAAQ,KAAK,OAAO,KAAK,IAAI,GAAG,IAAI,CAAC,MAAM;QAC9E,OAAO;IACT;AACF;AACA,SAAS,aAAa,KAAK,EAAE,GAAG;IAC9B,IAAI,UAAU,KAAK,GAAG;QACpB,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC;IAChE,OAAO;QACL,OAAO;IACT;AACF;AACA,MAAM,cAAc,CAAC,GAAG,IAAM,KAAK,GAAG,CAAC,IAAI,KAAK;AAChD,MAAM,WAAW,CAAC,cAAc,IAAI;IAClC,IAAI;IACJ,OAAO,SAAS,GAAG,IAAI;QACrB,aAAa,YAAY,CAAC;QAC1B,YAAY,aAAa,UAAU,CAAC,IAAM,GAAG,KAAK,CAAC,IAAI,EAAE,OAAO;IAClE;AACF;;CAOA,iCAAiC"}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@tanstack/virtual-core/dist/esm/index.js"],"sourcesContent":["import { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(element.getBoundingClientRect());\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      const box = entry.borderBoxSize[0];\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    element.removeEventListener(\"scrollend\", endHandler);\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    element.removeEventListener(\"scrollend\", endHandler);\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]\n  );\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            this._measureElement(entry.target, entry);\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.disconnect();\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        ...opts2\n      };\n    };\n    this.notify = (force, sync) => {\n      var _a, _b;\n      const { startIndex, endIndex } = this.range ?? {\n        startIndex: void 0,\n        endIndex: void 0\n      };\n      const range = this.calculateRange();\n      if (force || startIndex !== (range == null ? void 0 : range.startIndex) || endIndex !== (range == null ? void 0 : range.endIndex)) {\n        (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n      }\n    };\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n      this.targetWindow = null;\n      this.observer.disconnect();\n      this.elementsCache.clear();\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.notify(false, false);\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.notify(false, false);\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            const prevIsScrolling = this.isScrolling;\n            this.isScrolling = isScrolling;\n            this.notify(prevIsScrolling !== isScrolling, isScrolling);\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = memo(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane,\n            measureElement: this.measureElement\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],\n      (measurements, outerSize, scrollOffset) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getIndexes = memo(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (rangeExtractor, range, overscan, count) => {\n        return range === null ? [] : rangeExtractor({\n          startIndex: range.startIndex,\n          endIndex: range.endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const key = this.options.getItemKey(index);\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.getMeasurements()[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(true, false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (toOffset <= scrollOffset) {\n          align = \"start\";\n        } else if (toOffset >= scrollOffset + size) {\n          align = \"end\";\n        } else {\n          align = \"start\";\n        }\n      }\n      if (align === \"start\") {\n        toOffset = toOffset;\n      } else if (align === \"end\") {\n        toOffset = toOffset - size;\n      } else if (align === \"center\") {\n        toOffset = toOffset - size / 2;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.getMeasurements()[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(toOffset, align), align];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);\n      if (!offsetAndAlign) return;\n      const [offset, align] = offsetAndAlign;\n      this._scrollToOffset(offset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.elementsCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [latestOffset] = notUndefined(\n              this.getOffsetForIndex(index, align)\n            );\n            if (!approxEqual(latestOffset, this.getScrollOffset())) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else {\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(\n          ...measurements.slice(-this.options.lanes).map((m) => m.end)\n        );\n      }\n      return end - this.options.scrollMargin + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      var _a, _b;\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset\n}) {\n  const count = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  debounce,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n//# sourceMappingURL=index.js.map\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 758, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}