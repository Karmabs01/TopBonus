(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["chunks/ssr/node_modules_7537f4._.js", {

"[project]/node_modules/next/dist/server/web/spec-extension/cookies.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    RequestCookies: null,
    ResponseCookies: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RequestCookies: function() {
        return _cookies.RequestCookies;
    },
    ResponseCookies: function() {
        return _cookies.ResponseCookies;
    }
});
const _cookies = __turbopack_require__("[project]/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js (ecmascript, rsc)");

}.call(this) }),
"[project]/node_modules/next/dist/client/script.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$script$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$script$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/script.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/script.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$script$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$script$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/script.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

module.exports = __turbopack_require__("[project]/node_modules/next/dist/client/script.js (ecmascript, rsc)");

}.call(this) }),
"[project]/node_modules/lodash/isArray.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var isArray = Array.isArray;
module.exports = isArray;

}.call(this) }),
"[project]/node_modules/lodash/isLength.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
module.exports = isLength;

}.call(this) }),
"[project]/node_modules/lodash/isObject.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
module.exports = isObject;

}.call(this) }),
"[project]/node_modules/lodash/_objectToString.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString(value) {
    return nativeObjectToString.call(value);
}
module.exports = objectToString;

}.call(this) }),
"[project]/node_modules/lodash/_freeGlobal.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;

}.call(this) }),
"[project]/node_modules/lodash/_root.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var freeGlobal = __turbopack_require__("[project]/node_modules/lodash/_freeGlobal.js (ecmascript, rsc)");
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

}.call(this) }),
"[project]/node_modules/lodash/_Symbol.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var root = __turbopack_require__("[project]/node_modules/lodash/_root.js (ecmascript, rsc)");
var Symbol = root.Symbol;
module.exports = Symbol;

}.call(this) }),
"[project]/node_modules/lodash/_getRawTag.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var Symbol = __turbopack_require__("[project]/node_modules/lodash/_Symbol.js (ecmascript, rsc)");
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if ("TURBOPACK compile-time truthy", 1) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
module.exports = getRawTag;

}.call(this) }),
"[project]/node_modules/lodash/_baseGetTag.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var Symbol = __turbopack_require__("[project]/node_modules/lodash/_Symbol.js (ecmascript, rsc)"), getRawTag = __turbopack_require__("[project]/node_modules/lodash/_getRawTag.js (ecmascript, rsc)"), objectToString = __turbopack_require__("[project]/node_modules/lodash/_objectToString.js (ecmascript, rsc)");
var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
module.exports = baseGetTag;

}.call(this) }),
"[project]/node_modules/lodash/isFunction.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var baseGetTag = __turbopack_require__("[project]/node_modules/lodash/_baseGetTag.js (ecmascript, rsc)"), isObject = __turbopack_require__("[project]/node_modules/lodash/isObject.js (ecmascript, rsc)");
var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
module.exports = isFunction;

}.call(this) }),
"[project]/node_modules/lodash/isArrayLike.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var isFunction = __turbopack_require__("[project]/node_modules/lodash/isFunction.js (ecmascript, rsc)"), isLength = __turbopack_require__("[project]/node_modules/lodash/isLength.js (ecmascript, rsc)");
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
module.exports = isArrayLike;

}.call(this) }),
"[project]/node_modules/lodash/_overArg.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
module.exports = overArg;

}.call(this) }),
"[project]/node_modules/lodash/_nativeKeys.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var overArg = __turbopack_require__("[project]/node_modules/lodash/_overArg.js (ecmascript, rsc)");
var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

}.call(this) }),
"[project]/node_modules/lodash/_isPrototype.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var objectProto = Object.prototype;
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
module.exports = isPrototype;

}.call(this) }),
"[project]/node_modules/lodash/_baseKeys.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var isPrototype = __turbopack_require__("[project]/node_modules/lodash/_isPrototype.js (ecmascript, rsc)"), nativeKeys = __turbopack_require__("[project]/node_modules/lodash/_nativeKeys.js (ecmascript, rsc)");
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for(var key in Object(object)){
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
module.exports = baseKeys;

}.call(this) }),
"[project]/node_modules/lodash/_nodeUtil.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var freeGlobal = __turbopack_require__("[project]/node_modules/lodash/_freeGlobal.js (ecmascript, rsc)");
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function() {
    try {
        var types = freeModule && freeModule.require && freeModule.require('util').types;
        if (types) {
            return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
}();
module.exports = nodeUtil;

}.call(this) }),
"[project]/node_modules/lodash/_baseUnary.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
module.exports = baseUnary;

}.call(this) }),
"[project]/node_modules/lodash/isObjectLike.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
module.exports = isObjectLike;

}.call(this) }),
"[project]/node_modules/lodash/_baseIsTypedArray.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var baseGetTag = __turbopack_require__("[project]/node_modules/lodash/_baseGetTag.js (ecmascript, rsc)"), isLength = __turbopack_require__("[project]/node_modules/lodash/isLength.js (ecmascript, rsc)"), isObjectLike = __turbopack_require__("[project]/node_modules/lodash/isObjectLike.js (ecmascript, rsc)");
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
module.exports = baseIsTypedArray;

}.call(this) }),
"[project]/node_modules/lodash/isTypedArray.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var baseIsTypedArray = __turbopack_require__("[project]/node_modules/lodash/_baseIsTypedArray.js (ecmascript, rsc)"), baseUnary = __turbopack_require__("[project]/node_modules/lodash/_baseUnary.js (ecmascript, rsc)"), nodeUtil = __turbopack_require__("[project]/node_modules/lodash/_nodeUtil.js (ecmascript, rsc)");
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

}.call(this) }),
"[project]/node_modules/lodash/_isIndex.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
module.exports = isIndex;

}.call(this) }),
"[project]/node_modules/lodash/stubFalse.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

function stubFalse() {
    return false;
}
module.exports = stubFalse;

}.call(this) }),
"[project]/node_modules/lodash/isBuffer.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var root = __turbopack_require__("[project]/node_modules/lodash/_root.js (ecmascript, rsc)"), stubFalse = __turbopack_require__("[project]/node_modules/lodash/stubFalse.js (ecmascript, rsc)");
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root.Buffer : undefined;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;

}.call(this) }),
"[project]/node_modules/lodash/_baseIsArguments.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var baseGetTag = __turbopack_require__("[project]/node_modules/lodash/_baseGetTag.js (ecmascript, rsc)"), isObjectLike = __turbopack_require__("[project]/node_modules/lodash/isObjectLike.js (ecmascript, rsc)");
var argsTag = '[object Arguments]';
function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
}
module.exports = baseIsArguments;

}.call(this) }),
"[project]/node_modules/lodash/isArguments.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var baseIsArguments = __turbopack_require__("[project]/node_modules/lodash/_baseIsArguments.js (ecmascript, rsc)"), isObjectLike = __turbopack_require__("[project]/node_modules/lodash/isObjectLike.js (ecmascript, rsc)");
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
    return arguments;
}()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

}.call(this) }),
"[project]/node_modules/lodash/_baseTimes.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n){
        result[index] = iteratee(index);
    }
    return result;
}
module.exports = baseTimes;

}.call(this) }),
"[project]/node_modules/lodash/_arrayLikeKeys.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var baseTimes = __turbopack_require__("[project]/node_modules/lodash/_baseTimes.js (ecmascript, rsc)"), isArguments = __turbopack_require__("[project]/node_modules/lodash/isArguments.js (ecmascript, rsc)"), isArray = __turbopack_require__("[project]/node_modules/lodash/isArray.js (ecmascript, rsc)"), isBuffer = __turbopack_require__("[project]/node_modules/lodash/isBuffer.js (ecmascript, rsc)"), isIndex = __turbopack_require__("[project]/node_modules/lodash/_isIndex.js (ecmascript, rsc)"), isTypedArray = __turbopack_require__("[project]/node_modules/lodash/isTypedArray.js (ecmascript, rsc)");
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for(var key in value){
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
module.exports = arrayLikeKeys;

}.call(this) }),
"[project]/node_modules/lodash/keys.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var arrayLikeKeys = __turbopack_require__("[project]/node_modules/lodash/_arrayLikeKeys.js (ecmascript, rsc)"), baseKeys = __turbopack_require__("[project]/node_modules/lodash/_baseKeys.js (ecmascript, rsc)"), isArrayLike = __turbopack_require__("[project]/node_modules/lodash/isArrayLike.js (ecmascript, rsc)");
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
module.exports = keys;

}.call(this) }),
"[project]/node_modules/lodash/_arrayMap.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while(++index < length){
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
module.exports = arrayMap;

}.call(this) }),
"[project]/node_modules/lodash/_baseValues.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var arrayMap = __turbopack_require__("[project]/node_modules/lodash/_arrayMap.js (ecmascript, rsc)");
function baseValues(object, props) {
    return arrayMap(props, function(key) {
        return object[key];
    });
}
module.exports = baseValues;

}.call(this) }),
"[project]/node_modules/lodash/values.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var baseValues = __turbopack_require__("[project]/node_modules/lodash/_baseValues.js (ecmascript, rsc)"), keys = __turbopack_require__("[project]/node_modules/lodash/keys.js (ecmascript, rsc)");
function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
}
module.exports = values;

}.call(this) }),
"[project]/node_modules/lodash/_baseRandom.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var nativeFloor = Math.floor, nativeRandom = Math.random;
function baseRandom(lower, upper) {
    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}
module.exports = baseRandom;

}.call(this) }),
"[project]/node_modules/lodash/_shuffleSelf.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var baseRandom = __turbopack_require__("[project]/node_modules/lodash/_baseRandom.js (ecmascript, rsc)");
function shuffleSelf(array, size) {
    var index = -1, length = array.length, lastIndex = length - 1;
    size = size === undefined ? length : size;
    while(++index < size){
        var rand = baseRandom(index, lastIndex), value = array[rand];
        array[rand] = array[index];
        array[index] = value;
    }
    array.length = size;
    return array;
}
module.exports = shuffleSelf;

}.call(this) }),
"[project]/node_modules/lodash/_baseShuffle.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var shuffleSelf = __turbopack_require__("[project]/node_modules/lodash/_shuffleSelf.js (ecmascript, rsc)"), values = __turbopack_require__("[project]/node_modules/lodash/values.js (ecmascript, rsc)");
function baseShuffle(collection) {
    return shuffleSelf(values(collection));
}
module.exports = baseShuffle;

}.call(this) }),
"[project]/node_modules/lodash/_copyArray.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length){
        array[index] = source[index];
    }
    return array;
}
module.exports = copyArray;

}.call(this) }),
"[project]/node_modules/lodash/_arrayShuffle.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var copyArray = __turbopack_require__("[project]/node_modules/lodash/_copyArray.js (ecmascript, rsc)"), shuffleSelf = __turbopack_require__("[project]/node_modules/lodash/_shuffleSelf.js (ecmascript, rsc)");
function arrayShuffle(array) {
    return shuffleSelf(copyArray(array));
}
module.exports = arrayShuffle;

}.call(this) }),
"[project]/node_modules/lodash/shuffle.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var arrayShuffle = __turbopack_require__("[project]/node_modules/lodash/_arrayShuffle.js (ecmascript, rsc)"), baseShuffle = __turbopack_require__("[project]/node_modules/lodash/_baseShuffle.js (ecmascript, rsc)"), isArray = __turbopack_require__("[project]/node_modules/lodash/isArray.js (ecmascript, rsc)");
function shuffle(collection) {
    var func = isArray(collection) ? arrayShuffle : baseShuffle;
    return func(collection);
}
module.exports = shuffle;

}.call(this) }),
"[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_8bfabc._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_0bb5ef._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_5503db.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_d70a1d.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_process_browser_d734a8.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_react_index_0fe052.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_build_polyfills_process_930efa.js",
    "included": [
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_app-router-context_898dd5.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/app-router-context.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_hooks-client-context_ed2655.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/hooks-client-context.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_server-inserted-html_783da8.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/server-inserted-html.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_lazy-dynamic_dynamic-no-ssr_5b5544.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_client_components_error-boundary_b53fce.js",
    "included": [
      "[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript)"
    ]
  },
  "_next/static/chunks/node_modules_next_dist_client_components_error-boundary_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$error$2d$boundary$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$error$2d$boundary$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$error$2d$boundary$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$error$2d$boundary$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, client chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => __turbopack_import__("[project]/node_modules/next/dist/client/components/error-boundary.js (ecmascript, rsc)"),
    chunks: () => chunks,
});
const chunks = [];

})()),
"[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/app-router.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/[next]_overlay_client_ts_5ecd66._.js",
    "included": [
      "[next]/overlay/client.ts (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_dev_hot-reloader_tsx_db9090._.js",
    "included": [
      "[next]/dev/hot-reloader.tsx (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_platform_index_cf3e50.js",
    "included": [
      "[next]/compiled/platform/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_css_escape_index_7c772f.js",
    "included": [
      "[next]/compiled/css.escape/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_strip-ansi_index_0a9489.js",
    "included": [
      "[next]/compiled/strip-ansi/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_stacktrace-parser_index_b13037.js",
    "included": [
      "[next]/compiled/stacktrace-parser/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_anser_index_aab8ed.js",
    "included": [
      "[next]/compiled/anser/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[turbopack]_dev_client_a4c55d._.js",
    "included": [
      "[turbopack]/dev/client/hmr-client.ts (ecmascript)",
      "[turbopack]/dev/client/websocket.ts (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_7f5fb2._.js",
    "included": [
      "[project]/node_modules/next/dist/client/app-call-server.js (ecmascript)",
      "[project]/node_modules/next/dist/client/add-base-path.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/navigation.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/app-router.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/hash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/app-router-context.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/hooks-client-context.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/server-inserted-html.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react/jsx-runtime.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/scheduler/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react-dom/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react-server-dom-webpack/client.js (ecmascript)",
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)",
      "[project]/node_modules/next/dist/server/app-render/get-segment-param.js (ecmascript)",
      "[project]/node_modules/next/dist/server/future/helpers/interception-routes.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__class_private_field_loose_base_cjs_9b23c6._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__class_private_field_loose_key_cjs_d0a759._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_a172d2._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_910d6d._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__class_private_field_loose_base_206930.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_class_private_field_loose_base.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__class_private_field_loose_key_9e491c.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_class_private_field_loose_key.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_8e89a0.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_6bb19e.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  "_next/static/chunks/node_modules_next_dist_client_components_app-router_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$app$2d$router$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$app$2d$router$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$app$2d$router$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$app$2d$router$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/[next]_overlay_client_ts_8e0a93._.js",
    "included": [
      "[next]/overlay/client.ts (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_dev_hot-reloader_tsx_0655d7._.js",
    "included": [
      "[next]/dev/hot-reloader.tsx (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_platform_index_92dc0d.js",
    "included": [
      "[next]/compiled/platform/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_css_escape_index_368474.js",
    "included": [
      "[next]/compiled/css.escape/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_strip-ansi_index_ef6bc7.js",
    "included": [
      "[next]/compiled/strip-ansi/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_stacktrace-parser_index_0c555c.js",
    "included": [
      "[next]/compiled/stacktrace-parser/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[next]_compiled_anser_index_4da8bb.js",
    "included": [
      "[next]/compiled/anser/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/[turbopack]_dev_client_dfbd04._.js",
    "included": [
      "[turbopack]/dev/client/hmr-client.ts (ecmascript)",
      "[turbopack]/dev/client/websocket.ts (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_d4cdf1._.js",
    "included": [
      "[project]/node_modules/next/dist/client/add-base-path.js (ecmascript)",
      "[project]/node_modules/next/dist/client/app-call-server.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/navigation.js (ecmascript)",
      "[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react/jsx-runtime.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/scheduler/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react-dom/index.js (ecmascript)",
      "[project]/node_modules/next/dist/compiled/react-server-dom-webpack/client.js (ecmascript)",
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/app-router-context.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/hooks-client-context.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/server-inserted-html.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/hash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-no-ssr.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js (ecmascript)",
      "[project]/node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js (ecmascript)",
      "[project]/node_modules/next/dist/server/app-render/get-segment-param.js (ecmascript)",
      "[project]/node_modules/next/dist/server/future/helpers/interception-routes.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__class_private_field_loose_base_cjs_b3134a._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__class_private_field_loose_key_cjs_af59fd._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_802010._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_d98411._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__class_private_field_loose_base_cd9a5f.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_class_private_field_loose_base.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__class_private_field_loose_key_72ac83.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_class_private_field_loose_key.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_087633.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_36b36c.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  "_next/static/chunks/node_modules_next_dist_client_components_layout-router_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$layout$2d$router$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$layout$2d$router$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$layout$2d$router$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$layout$2d$router$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_wildcard_cjs_7dd036._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_5180f8._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_wildcard_7f91d5.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_wildcard.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_7bf983.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_process_browser_59bcba.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_react_index_8b15c6.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_build_polyfills_process_785375.js",
    "included": [
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_shared_lib_app-router-context_6dabfc.js",
    "included": [
      "[project]/node_modules/next/dist/shared/lib/app-router-context.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_client_components_render-from-template-context_b53fce.js",
    "included": [
      "[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript)"
    ]
  },
  "_next/static/chunks/node_modules_next_dist_client_components_render-from-template-context_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$render$2d$from$2d$template$2d$context$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/client/components/async-local-storage.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createAsyncLocalStorage", {
    enumerable: true,
    get: function() {
        return createAsyncLocalStorage;
    }
});
const sharedAsyncLocalStorageNotAvailableError = new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
class FakeAsyncLocalStorage {
    disable() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    getStore() {
        return undefined;
    }
    run() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    exit() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    enterWith() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
}
const maybeGlobalAsyncLocalStorage = globalThis.AsyncLocalStorage;
function createAsyncLocalStorage() {
    if (maybeGlobalAsyncLocalStorage) {
        return new maybeGlobalAsyncLocalStorage();
    }
    return new FakeAsyncLocalStorage();
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/static-generation-async-storage.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "staticGenerationAsyncStorage", {
    enumerable: true,
    get: function() {
        return staticGenerationAsyncStorage;
    }
});
const _asynclocalstorage = __turbopack_require__("[project]/node_modules/next/dist/client/components/async-local-storage.js (ecmascript, rsc)");
const staticGenerationAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/hooks-server-context.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DYNAMIC_ERROR_CODE: null,
    DynamicServerError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DYNAMIC_ERROR_CODE: function() {
        return DYNAMIC_ERROR_CODE;
    },
    DynamicServerError: function() {
        return DynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
class DynamicServerError extends Error {
    constructor(type){
        super("Dynamic server usage: " + type);
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/static-generation-bailout.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "staticGenerationBailout", {
    enumerable: true,
    get: function() {
        return staticGenerationBailout;
    }
});
const _hooksservercontext = __turbopack_require__("[project]/node_modules/next/dist/client/components/hooks-server-context.js (ecmascript, rsc)");
const _staticgenerationasyncstorage = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-async-storage.js (ecmascript, rsc)");
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args);
        this.code = "NEXT_STATIC_GEN_BAILOUT";
    }
}
const staticGenerationBailout = (reason, opts)=>{
    const staticGenerationStore = _staticgenerationasyncstorage.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {
        return true;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.dynamicShouldError) {
        const { dynamic = "error", link } = opts || {};
        const suffix = link ? " See more info here: " + link : "";
        throw new StaticGenBailoutError('Page with `dynamic = "' + dynamic + "\"` couldn't be rendered statically because it used `" + reason + "`." + suffix);
    }
    if (staticGenerationStore) {
        staticGenerationStore.revalidate = 0;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {
        const err = new _hooksservercontext.DynamicServerError(reason);
        staticGenerationStore.dynamicUsageDescription = reason;
        staticGenerationStore.dynamicUsageStack = err.stack;
        throw err;
    }
    return false;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/searchparams-bailout-proxy.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createSearchParamsBailoutProxy", {
    enumerable: true,
    get: function() {
        return createSearchParamsBailoutProxy;
    }
});
const _staticgenerationbailout = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-bailout.js (ecmascript, rsc)");
function createSearchParamsBailoutProxy() {
    return new Proxy({}, {
        get (_target, prop) {
            if (typeof prop === "string") {
                (0, _staticgenerationbailout.staticGenerationBailout)("searchParams." + prop);
            }
        }
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/action-async-storage.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "actionAsyncStorage", {
    enumerable: true,
    get: function() {
        return actionAsyncStorage;
    }
});
const _asynclocalstorage = __turbopack_require__("[project]/node_modules/next/dist/client/components/async-local-storage.js (ecmascript, rsc)");
const actionAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/request-async-storage.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "requestAsyncStorage", {
    enumerable: true,
    get: function() {
        return requestAsyncStorage;
    }
});
const _asynclocalstorage = __turbopack_require__("[project]/node_modules/next/dist/client/components/async-local-storage.js (ecmascript, rsc)");
const requestAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
}

}.call(this) }),
"[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => "[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript)",
    chunks: () => chunks,
});
const chunks = [
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_cjs__interop_require_default_cjs_ae2fa0._.js",
    "included": [
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_@swc_helpers_esm__interop_require_default_810676.js",
    "included": [
      "[project]/node_modules/@swc/helpers/esm/_interop_require_default.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_process_browser_a2df53.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_compiled_react_index_c4bfc2.js",
    "included": [
      "[project]/node_modules/next/dist/compiled/react/index.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/node_modules_next_dist_build_polyfills_process_235e98.js",
    "included": [
      "[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript)"
    ]
  },
  {
    "path": "_next/static/chunks/0f475_dist_client_components_static-generation-searchparams-bailout-provider_b53fce.js",
    "included": [
      "[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript)"
    ]
  },
  "_next/static/chunks/0f475_dist_client_components_static-generation-searchparams-bailout-provider_5771e1.js"
];

})()),
"[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__ }) => (() => {

var __TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$static$2d$generation$2d$searchparams$2d$bailout$2d$provider$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$static$2d$generation$2d$searchparams$2d$bailout$2d$provider$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__ = __turbopack_import__("[next]/entry/app/server-to-client-ssr.tsx/(CLIENT_MODULE)/[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, with chunking context scope)/(CLIENT_CHUNKS)/[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, chunks) (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
"TURBOPACK { transition: server-to-client }";
;
__turbopack_export_namespace__(__TURBOPACK__imported__module__$5b$next$5d2f$entry$2f$app$2f$server$2d$to$2d$client$2d$ssr$2e$tsx$2f28$CLIENT_MODULE$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$static$2d$generation$2d$searchparams$2d$bailout$2d$provider$2e$js__$28$ecmascript$2c$__with__chunking__context__scope$292f28$CLIENT_CHUNKS$292f5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$static$2d$generation$2d$searchparams$2d$bailout$2d$provider$2e$js__$28$ecmascript$2c$__chunks$29$__$28$ecmascript$29$__["default"]);

})()),
"[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

(function() {
    var e = {
        229: function(e) {
            var t = e.exports = {};
            var r;
            var n;
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            (function() {
                try {
                    if (typeof setTimeout === "function") {
                        r = setTimeout;
                    } else {
                        r = defaultSetTimout;
                    }
                } catch (e) {
                    r = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === "function") {
                        n = clearTimeout;
                    } else {
                        n = defaultClearTimeout;
                    }
                } catch (e) {
                    n = defaultClearTimeout;
                }
            })();
            function runTimeout(e) {
                if (r === setTimeout) {
                    return setTimeout(e, 0);
                }
                if ((r === defaultSetTimout || !r) && setTimeout) {
                    r = setTimeout;
                    return setTimeout(e, 0);
                }
                try {
                    return r(e, 0);
                } catch (t) {
                    try {
                        return r.call(null, e, 0);
                    } catch (t) {
                        return r.call(this, e, 0);
                    }
                }
            }
            function runClearTimeout(e) {
                if (n === clearTimeout) {
                    return clearTimeout(e);
                }
                if ((n === defaultClearTimeout || !n) && clearTimeout) {
                    n = clearTimeout;
                    return clearTimeout(e);
                }
                try {
                    return n(e);
                } catch (t) {
                    try {
                        return n.call(null, e);
                    } catch (t) {
                        return n.call(this, e);
                    }
                }
            }
            var i = [];
            var o = false;
            var u;
            var a = -1;
            function cleanUpNextTick() {
                if (!o || !u) {
                    return;
                }
                o = false;
                if (u.length) {
                    i = u.concat(i);
                } else {
                    a = -1;
                }
                if (i.length) {
                    drainQueue();
                }
            }
            function drainQueue() {
                if (o) {
                    return;
                }
                var e = runTimeout(cleanUpNextTick);
                o = true;
                var t = i.length;
                while(t){
                    u = i;
                    i = [];
                    while(++a < t){
                        if (u) {
                            u[a].run();
                        }
                    }
                    a = -1;
                    t = i.length;
                }
                u = null;
                o = false;
                runClearTimeout(e);
            }
            t.nextTick = function(e) {
                var t = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for(var r = 1; r < arguments.length; r++){
                        t[r - 1] = arguments[r];
                    }
                }
                i.push(new Item(e, t));
                if (i.length === 1 && !o) {
                    runTimeout(drainQueue);
                }
            };
            function Item(e, t) {
                this.fun = e;
                this.array = t;
            }
            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            };
            t.title = "browser";
            t.browser = true;
            t.env = {};
            t.argv = [];
            t.version = "";
            t.versions = {};
            function noop() {}
            t.on = noop;
            t.addListener = noop;
            t.once = noop;
            t.off = noop;
            t.removeListener = noop;
            t.removeAllListeners = noop;
            t.emit = noop;
            t.prependListener = noop;
            t.prependOnceListener = noop;
            t.listeners = function(e) {
                return [];
            };
            t.binding = function(e) {
                throw new Error("process.binding is not supported");
            };
            t.cwd = function() {
                return "/";
            };
            t.chdir = function(e) {
                throw new Error("process.chdir is not supported");
            };
            t.umask = function() {
                return 0;
            };
        }
    };
    var t = {};
    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports;
        }
        var i = t[r] = {
            exports: {}
        };
        var o = true;
        try {
            e[r](i, i.exports, __nccwpck_require__);
            o = false;
        } finally{
            if (o) delete t[r];
        }
        return i.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var r = __nccwpck_require__(229);
    module.exports = r;
})();

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react/cjs/react.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = '18.3.0-canary-9377e1010-20230712';
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var ReactCurrentDispatcher$1 = {
            current: null
        };
        var ReactCurrentCache = {
            current: null
        };
        var ReactCurrentBatchConfig = {
            transition: null
        };
        var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false,
            didUsePromise: false
        };
        var ReactCurrentOwner = {
            current: null
        };
        var ReactDebugCurrentFrame$1 = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
            {
                currentExtraStackFrame = stack;
            }
        }
        {
            ReactDebugCurrentFrame$1.setExtraStackFrame = function(stack) {
                {
                    currentExtraStackFrame = stack;
                }
            };
            ReactDebugCurrentFrame$1.getCurrentStack = null;
            ReactDebugCurrentFrame$1.getStackAddendum = function() {
                var stack = '';
                if (currentExtraStackFrame) {
                    stack += currentExtraStackFrame;
                }
                var impl = ReactDebugCurrentFrame$1.getCurrentStack;
                if (impl) {
                    stack += impl() || '';
                }
                return stack;
            };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ContextRegistry$1 = {};
        var ReactSharedInternals = {
            ReactCurrentDispatcher: ReactCurrentDispatcher$1,
            ReactCurrentCache: ReactCurrentCache,
            ReactCurrentBatchConfig: ReactCurrentBatchConfig,
            ReactCurrentOwner: ReactCurrentOwner
        };
        {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame$1;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        {
            ReactSharedInternals.ContextRegistry = ContextRegistry$1;
        }
        function warn(format) {
            {
                {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
            {
                var _constructor = publicInstance.constructor;
                var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
                var warningKey = componentName + "." + callerName;
                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                    return;
                }
                error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
                didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
        }
        var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
                return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
                warnNoop(publicInstance, 'forceUpdate');
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
                warnNoop(publicInstance, 'replaceState');
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
                warnNoop(publicInstance, 'setState');
            }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
            Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
                throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
            }
            this.updater.enqueueSetState(this, partialState, callback, 'setState');
        };
        Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
        };
        {
            var deprecatedAPIs = {
                isMounted: [
                    'isMounted',
                    'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'
                ],
                replaceState: [
                    'replaceState',
                    'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'
                ]
            };
            var defineDeprecationWarning = function(methodName, info) {
                Object.defineProperty(Component.prototype, methodName, {
                    get: function() {
                        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                        return undefined;
                    }
                });
            };
            for(var fnName in deprecatedAPIs){
                if (deprecatedAPIs.hasOwnProperty(fnName)) {
                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                }
            }
        }
        function ComponentDummy() {}
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
            var refObject = {
                current: null
            };
            {
                Object.seal(refObject);
            }
            return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        function typeName(value) {
            {
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                return type;
            }
        }
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                } catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            return '' + value;
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                    return testStringCoercion(value);
                }
            }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromType(type) {
            if (type == null) {
                return null;
            }
            {
                if (typeof type.tag === 'number') {
                    error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                }
            }
            if (typeof type === 'function') {
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
                case REACT_CACHE_TYPE:
                    {
                        return 'Cache';
                    }
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    case REACT_PROVIDER_TYPE:
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            } catch (x) {
                                return null;
                            }
                        }
                    case REACT_SERVER_CONTEXT_TYPE:
                        {
                            var context2 = type;
                            return (context2.displayName || context2._globalName) + '.Provider';
                        }
                }
            }
            return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
            didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
            {
                if (hasOwnProperty.call(config, 'ref')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.ref !== undefined;
        }
        function hasValidKey(config) {
            {
                if (hasOwnProperty.call(config, 'key')) {
                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
                    if (getter && getter.isReactWarning) {
                        return false;
                    }
                }
            }
            return config.key !== undefined;
        }
        function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
                {
                    if (!specialPropKeyWarningShown) {
                        specialPropKeyWarningShown = true;
                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, 'key', {
                get: warnAboutAccessingKey,
                configurable: true
            });
        }
        function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
                {
                    if (!specialPropRefWarningShown) {
                        specialPropRefWarningShown = true;
                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
                    }
                }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, 'ref', {
                get: warnAboutAccessingRef,
                configurable: true
            });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
            {
                if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                    var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
        }
        function ReactElement(type, key, ref, self, source, owner, props) {
            var element = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: ref,
                props: props,
                _owner: owner
            };
            {
                element._store = {};
                Object.defineProperty(element._store, 'validated', {
                    configurable: false,
                    enumerable: false,
                    writable: true,
                    value: false
                });
                Object.defineProperty(element, '_self', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: self
                });
                Object.defineProperty(element, '_source', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: source
                });
                if (Object.freeze) {
                    Object.freeze(element.props);
                    Object.freeze(element);
                }
            }
            return element;
        }
        function createElement$1(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self = null;
            var source = null;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    {
                        warnIfStringRefCannotBeAutoConverted(config);
                    }
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                self = config.__self === undefined ? null : config.__self;
                source = config.__source === undefined ? null : config.__source;
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        props[propName] = config[propName];
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                {
                    if (Object.freeze) {
                        Object.freeze(childArray);
                    }
                }
                props.children = childArray;
            }
            if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for(propName in defaultProps){
                    if (props[propName] === undefined) {
                        props[propName] = defaultProps[propName];
                    }
                }
            }
            {
                if (key || ref) {
                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
                    if (key) {
                        defineKeyPropWarningGetter(props, displayName);
                    }
                    if (ref) {
                        defineRefPropWarningGetter(props, displayName);
                    }
                }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
        }
        function cloneElement$1(element, config, children) {
            if (element === null || element === undefined) {
                throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
                if (hasValidRef(config)) {
                    ref = config.ref;
                    owner = ReactCurrentOwner.current;
                }
                if (hasValidKey(config)) {
                    {
                        checkKeyStringCoercion(config.key);
                    }
                    key = '' + config.key;
                }
                var defaultProps;
                if (element.type && element.type.defaultProps) {
                    defaultProps = element.type.defaultProps;
                }
                for(propName in config){
                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                        if (config[propName] === undefined && defaultProps !== undefined) {
                            props[propName] = defaultProps[propName];
                        } else {
                            props[propName] = config[propName];
                        }
                    }
                }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for(var i = 0; i < childrenLength; i++){
                    childArray[i] = arguments[i + 2];
                }
                props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = '.';
        var SUBSEPARATOR = ':';
        function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
                '=': '=0',
                ':': '=2'
            };
            var escapedString = key.replace(escapeRegex, function(match) {
                return escaperLookup[match];
            });
            return '$' + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, '$&/');
        }
        function getElementKey(element, index) {
            if (typeof element === 'object' && element !== null && element.key != null) {
                {
                    checkKeyStringCoercion(element.key);
                }
                return escape('' + element.key);
            }
            return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === 'undefined' || type === 'boolean') {
                children = null;
            }
            var invokeCallback = false;
            if (children === null) {
                invokeCallback = true;
            } else {
                switch(type){
                    case 'string':
                    case 'number':
                        invokeCallback = true;
                        break;
                    case 'object':
                        switch(children.$$typeof){
                            case REACT_ELEMENT_TYPE:
                            case REACT_PORTAL_TYPE:
                                invokeCallback = true;
                        }
                }
            }
            if (invokeCallback) {
                var _child = children;
                var mappedChild = callback(_child);
                var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
                if (isArray(mappedChild)) {
                    var escapedChildKey = '';
                    if (childKey != null) {
                        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                    }
                    mapIntoArray(mappedChild, array, escapedChildKey, '', function(c) {
                        return c;
                    });
                } else if (mappedChild != null) {
                    if (isValidElement(mappedChild)) {
                        {
                            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                                checkKeyStringCoercion(mappedChild.key);
                            }
                        }
                        mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                    }
                    array.push(mappedChild);
                }
                return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
                for(var i = 0; i < children.length; i++){
                    child = children[i];
                    nextName = nextNamePrefix + getElementKey(child, i);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === 'function') {
                    var iterableChildren = children;
                    {
                        if (iteratorFn === iterableChildren.entries) {
                            if (!didWarnAboutMaps) {
                                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                            }
                            didWarnAboutMaps = true;
                        }
                    }
                    var iterator = iteratorFn.call(iterableChildren);
                    var step;
                    var ii = 0;
                    while(!(step = iterator.next()).done){
                        child = step.value;
                        nextName = nextNamePrefix + getElementKey(child, ii++);
                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                    }
                } else if (type === 'object') {
                    var childrenString = String(children);
                    throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
                }
            }
            return subtreeCount;
        }
        function mapChildren(children, func, context) {
            if (children == null) {
                return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, '', '', function(child) {
                return func.call(context, child, count++);
            });
            return result;
        }
        function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
                n++;
            });
            return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        }
        function toArray(children) {
            return mapChildren(children, function(child) {
                return child;
            }) || [];
        }
        function onlyChild(children) {
            if (!isValidElement(children)) {
                throw new Error('React.Children.only expected to receive a single React element child.');
            }
            return children;
        }
        function createContext(defaultValue) {
            var context = {
                $$typeof: REACT_CONTEXT_TYPE,
                _currentValue: defaultValue,
                _currentValue2: defaultValue,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null
            };
            context.Provider = {
                $$typeof: REACT_PROVIDER_TYPE,
                _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
                var Consumer = {
                    $$typeof: REACT_CONTEXT_TYPE,
                    _context: context
                };
                Object.defineProperties(Consumer, {
                    Provider: {
                        get: function() {
                            if (!hasWarnedAboutUsingConsumerProvider) {
                                hasWarnedAboutUsingConsumerProvider = true;
                                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
                            }
                            return context.Provider;
                        },
                        set: function(_Provider) {
                            context.Provider = _Provider;
                        }
                    },
                    _currentValue: {
                        get: function() {
                            return context._currentValue;
                        },
                        set: function(_currentValue) {
                            context._currentValue = _currentValue;
                        }
                    },
                    _currentValue2: {
                        get: function() {
                            return context._currentValue2;
                        },
                        set: function(_currentValue2) {
                            context._currentValue2 = _currentValue2;
                        }
                    },
                    _threadCount: {
                        get: function() {
                            return context._threadCount;
                        },
                        set: function(_threadCount) {
                            context._threadCount = _threadCount;
                        }
                    },
                    Consumer: {
                        get: function() {
                            if (!hasWarnedAboutUsingNestedContextConsumers) {
                                hasWarnedAboutUsingNestedContextConsumers = true;
                                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                            }
                            return context.Consumer;
                        }
                    },
                    displayName: {
                        get: function() {
                            return context.displayName;
                        },
                        set: function(displayName) {
                            if (!hasWarnedAboutDisplayNameOnConsumer) {
                                warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                                hasWarnedAboutDisplayNameOnConsumer = true;
                            }
                        }
                    }
                });
                context.Consumer = Consumer;
            }
            {
                context._currentRenderer = null;
                context._currentRenderer2 = null;
            }
            return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
                var ctor = payload._result;
                var thenable = ctor();
                thenable.then(function(moduleObject) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var resolved = payload;
                        resolved._status = Resolved;
                        resolved._result = moduleObject;
                    }
                }, function(error) {
                    if (payload._status === Pending || payload._status === Uninitialized) {
                        var rejected = payload;
                        rejected._status = Rejected;
                        rejected._result = error;
                    }
                });
                if (payload._status === Uninitialized) {
                    var pending = payload;
                    pending._status = Pending;
                    pending._result = thenable;
                }
            }
            if (payload._status === Resolved) {
                var moduleObject = payload._result;
                {
                    if (moduleObject === undefined) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
                    }
                }
                {
                    if (!('default' in moduleObject)) {
                        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + 'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
                    }
                }
                return moduleObject.default;
            } else {
                throw payload._result;
            }
        }
        function lazy(ctor) {
            var payload = {
                _status: Uninitialized,
                _result: ctor
            };
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: payload,
                _init: lazyInitializer
            };
            {
                var defaultProps;
                var propTypes;
                Object.defineProperties(lazyType, {
                    defaultProps: {
                        configurable: true,
                        get: function() {
                            return defaultProps;
                        },
                        set: function(newDefaultProps) {
                            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            defaultProps = newDefaultProps;
                            Object.defineProperty(lazyType, 'defaultProps', {
                                enumerable: true
                            });
                        }
                    },
                    propTypes: {
                        configurable: true,
                        get: function() {
                            return propTypes;
                        },
                        set: function(newPropTypes) {
                            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
                            propTypes = newPropTypes;
                            Object.defineProperty(lazyType, 'propTypes', {
                                enumerable: true
                            });
                        }
                    }
                });
            }
            return lazyType;
        }
        function forwardRef(render) {
            {
                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                    error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
                } else if (typeof render !== 'function') {
                    error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
                } else {
                    if (render.length !== 0 && render.length !== 2) {
                        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
                    }
                }
                if (render != null) {
                    if (render.defaultProps != null || render.propTypes != null) {
                        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
                    }
                }
            }
            var elementType = {
                $$typeof: REACT_FORWARD_REF_TYPE,
                render: render
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!render.name && !render.displayName) {
                            render.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');
        function isValidElementType(type) {
            if (typeof type === 'string' || typeof type === 'function') {
                return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
                return true;
            }
            if (typeof type === 'object' && type !== null) {
                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {
                    return true;
                }
            }
            return false;
        }
        function memo(type, compare) {
            {
                if (!isValidElementType(type)) {
                    error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
                }
            }
            var elementType = {
                $$typeof: REACT_MEMO_TYPE,
                type: type,
                compare: compare === undefined ? null : compare
            };
            {
                var ownName;
                Object.defineProperty(elementType, 'displayName', {
                    enumerable: false,
                    configurable: true,
                    get: function() {
                        return ownName;
                    },
                    set: function(name) {
                        ownName = name;
                        if (!type.name && !type.displayName) {
                            type.displayName = name;
                        }
                    }
                });
            }
            return elementType;
        }
        var UNTERMINATED = 0;
        var TERMINATED = 1;
        var ERRORED = 2;
        function createCacheRoot() {
            return new WeakMap();
        }
        function createCacheNode() {
            return {
                s: UNTERMINATED,
                v: undefined,
                o: null,
                p: null
            };
        }
        function cache(fn) {
            return function() {
                var dispatcher = ReactCurrentCache.current;
                if (!dispatcher) {
                    return fn.apply(null, arguments);
                }
                var fnMap = dispatcher.getCacheForType(createCacheRoot);
                var fnNode = fnMap.get(fn);
                var cacheNode;
                if (fnNode === undefined) {
                    cacheNode = createCacheNode();
                    fnMap.set(fn, cacheNode);
                } else {
                    cacheNode = fnNode;
                }
                for(var i = 0, l = arguments.length; i < l; i++){
                    var arg = arguments[i];
                    if (typeof arg === 'function' || typeof arg === 'object' && arg !== null) {
                        var objectCache = cacheNode.o;
                        if (objectCache === null) {
                            cacheNode.o = objectCache = new WeakMap();
                        }
                        var objectNode = objectCache.get(arg);
                        if (objectNode === undefined) {
                            cacheNode = createCacheNode();
                            objectCache.set(arg, cacheNode);
                        } else {
                            cacheNode = objectNode;
                        }
                    } else {
                        var primitiveCache = cacheNode.p;
                        if (primitiveCache === null) {
                            cacheNode.p = primitiveCache = new Map();
                        }
                        var primitiveNode = primitiveCache.get(arg);
                        if (primitiveNode === undefined) {
                            cacheNode = createCacheNode();
                            primitiveCache.set(arg, cacheNode);
                        } else {
                            cacheNode = primitiveNode;
                        }
                    }
                }
                if (cacheNode.s === TERMINATED) {
                    return cacheNode.v;
                }
                if (cacheNode.s === ERRORED) {
                    throw cacheNode.v;
                }
                try {
                    var result = fn.apply(null, arguments);
                    var terminatedNode = cacheNode;
                    terminatedNode.s = TERMINATED;
                    terminatedNode.v = result;
                    return result;
                } catch (error) {
                    var erroredNode = cacheNode;
                    erroredNode.s = ERRORED;
                    erroredNode.v = error;
                    throw error;
                }
            };
        }
        function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher$1.current;
            {
                if (dispatcher === null) {
                    error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
                }
            }
            return dispatcher;
        }
        function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
                if (Context._context !== undefined) {
                    var realContext = Context._context;
                    if (realContext.Consumer === Context) {
                        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
                    } else if (realContext.Provider === Context) {
                        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
                    }
                }
            }
            return dispatcher.useContext(Context);
        }
        function useState(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
            {
                var dispatcher = resolveDispatcher();
                return dispatcher.useDebugValue(value, formatterFn);
            }
        }
        function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
        }
        function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        function useCacheRefresh() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCacheRefresh();
        }
        function use(usable) {
            var dispatcher = resolveDispatcher();
            return dispatcher.use(usable);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd;
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    };
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
                if (prefix === undefined) {
                    try {
                        throw Error();
                    } catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                }
                return '\n' + prefix + name;
            }
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = null;
                disableLogs();
            }
            try {
                if (construct) {
                    var Fake = function() {
                        throw Error();
                    };
                    Object.defineProperty(Fake.prototype, 'props', {
                        set: function() {
                            throw Error();
                        }
                    });
                    if (typeof Reflect === 'object' && Reflect.construct) {
                        try {
                            Reflect.construct(Fake, []);
                        } catch (x) {
                            control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                    } else {
                        try {
                            Fake.call();
                        } catch (x) {
                            control = x;
                        }
                        fn.call(Fake.prototype);
                    }
                } else {
                    try {
                        throw Error();
                    } catch (x) {
                        control = x;
                    }
                    var maybePromise = fn();
                    if (maybePromise && typeof maybePromise.catch === 'function') {
                        maybePromise.catch(function() {});
                    }
                }
            } catch (sample) {
                if (sample && control && typeof sample.stack === 'string') {
                    var sampleLines = sample.stack.split('\n');
                    var controlLines = control.stack.split('\n');
                    var s = sampleLines.length - 1;
                    var c = controlLines.length - 1;
                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                        c--;
                    }
                    for(; s >= 1 && c >= 0; s--, c--){
                        if (sampleLines[s] !== controlLines[c]) {
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--;
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        }
                                        return _frame;
                                    }
                                }while (s >= 1 && c >= 0)
                            }
                            break;
                        }
                    }
                }
            } finally{
                reentry = false;
                {
                    ReactCurrentDispatcher.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function shouldConstruct(Component) {
            var prototype = Component.prototype;
            return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
                return '';
            }
            if (typeof type === 'function') {
                {
                    return describeNativeComponentFrame(type, shouldConstruct(type));
                }
            }
            if (typeof type === 'string') {
                return describeBuiltInComponentFrame(type);
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame('Suspense');
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame('SuspenseList');
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeFunctionComponentFrame(type.render);
                    case REACT_MEMO_TYPE:
                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    ReactDebugCurrentFrame.setExtraStackFrame(stack);
                } else {
                    ReactDebugCurrentFrame.setExtraStackFrame(null);
                }
            }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
                var has = Function.call.bind(hasOwnProperty);
                for(var typeSpecName in typeSpecs){
                    if (has(typeSpecs, typeSpecName)) {
                        var error$1 = void 0;
                        try {
                            if (typeof typeSpecs[typeSpecName] !== 'function') {
                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                err.name = 'Invariant Violation';
                                throw err;
                            }
                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                        } catch (ex) {
                            error$1 = ex;
                        }
                        if (error$1 && !(error$1 instanceof Error)) {
                            setCurrentlyValidatingElement$1(element);
                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
                            setCurrentlyValidatingElement$1(null);
                        }
                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                            loggedTypeFailures[error$1.message] = true;
                            setCurrentlyValidatingElement$1(element);
                            error('Failed %s type: %s', location, error$1.message);
                            setCurrentlyValidatingElement$1(null);
                        }
                    }
                }
            }
        }
        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
        function setCurrentlyValidatingElement(element) {
            {
                if (element) {
                    var owner = element._owner;
                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                    setExtraStackFrame(stack);
                } else {
                    setExtraStackFrame(null);
                }
            }
        }
        var propTypesMisspellWarningShown;
        {
            propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
                var name = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (name) {
                    return '\n\nCheck the render method of `' + name + '`.';
                }
            }
            return '';
        }
        function getSourceInfoErrorAddendum(source) {
            if (source !== undefined) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                var lineNumber = source.lineNumber;
                return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
            }
            return '';
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== undefined) {
                return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return '';
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
                var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                    info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
            }
            return info;
        }
        function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
                return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = '';
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
                setCurrentlyValidatingElement(element);
                error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
                setCurrentlyValidatingElement(null);
            }
        }
        function validateChildKeys(node, parentType) {
            if (typeof node !== 'object' || !node) {
                return;
            }
            if (node.$$typeof === REACT_CLIENT_REFERENCE) ;
            else if (isArray(node)) {
                for(var i = 0; i < node.length; i++){
                    var child = node[i];
                    if (isValidElement(child)) {
                        validateExplicitKey(child, parentType);
                    }
                }
            } else if (isValidElement(node)) {
                if (node._store) {
                    node._store.validated = true;
                }
            } else {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === 'function') {
                    if (iteratorFn !== node.entries) {
                        var iterator = iteratorFn.call(node);
                        var step;
                        while(!(step = iterator.next()).done){
                            if (isValidElement(step.value)) {
                                validateExplicitKey(step.value, parentType);
                            }
                        }
                    }
                }
            }
        }
        function validatePropTypes(element) {
            {
                var type = element.type;
                if (type === null || type === undefined || typeof type === 'string') {
                    return;
                }
                if (type.$$typeof === REACT_CLIENT_REFERENCE) {
                    return;
                }
                var propTypes;
                if (typeof type === 'function') {
                    propTypes = type.propTypes;
                } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                    propTypes = type.propTypes;
                } else {
                    return;
                }
                if (propTypes) {
                    var name = getComponentNameFromType(type);
                    checkPropTypes(propTypes, element.props, 'prop', name, element);
                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
                    propTypesMisspellWarningShown = true;
                    var _name = getComponentNameFromType(type);
                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
                }
                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
                }
            }
        }
        function validateFragmentProps(fragment) {
            {
                var keys = Object.keys(fragment.props);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if (key !== 'children' && key !== 'key') {
                        setCurrentlyValidatingElement(fragment);
                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
                        setCurrentlyValidatingElement(null);
                        break;
                    }
                }
                if (fragment.ref !== null) {
                    setCurrentlyValidatingElement(fragment);
                    error('Invalid attribute `ref` supplied to `React.Fragment`.');
                    setCurrentlyValidatingElement(null);
                }
            }
        }
        function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
                var info = '';
                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
                    info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendumForProps(props);
                if (sourceInfo) {
                    info += sourceInfo;
                } else {
                    info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                    typeString = 'null';
                } else if (isArray(type)) {
                    typeString = 'array';
                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                    typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
                    info = ' Did you accidentally export a JSX literal instead of a component?';
                } else {
                    typeString = typeof type;
                }
                {
                    error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
                }
            }
            var element = createElement$1.apply(this, arguments);
            if (element == null) {
                return element;
            }
            if (validType) {
                for(var i = 2; i < arguments.length; i++){
                    validateChildKeys(arguments[i], type);
                }
            }
            if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
            } else {
                validatePropTypes(element);
            }
            return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
                if (!didWarnAboutDeprecatedCreateFactory) {
                    didWarnAboutDeprecatedCreateFactory = true;
                    warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
                }
                Object.defineProperty(validatedFactory, 'type', {
                    enumerable: false,
                    get: function() {
                        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
                        Object.defineProperty(this, 'type', {
                            value: type
                        });
                        return type;
                    }
                });
            }
            return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement$1.apply(this, arguments);
            for(var i = 2; i < arguments.length; i++){
                validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
        }
        var ContextRegistry = ReactSharedInternals.ContextRegistry;
        function createServerContext(globalName, defaultValue) {
            var wasDefined = true;
            if (!ContextRegistry[globalName]) {
                wasDefined = false;
                var _context = {
                    $$typeof: REACT_SERVER_CONTEXT_TYPE,
                    _currentValue: defaultValue,
                    _currentValue2: defaultValue,
                    _defaultValue: defaultValue,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _globalName: globalName
                };
                _context.Provider = {
                    $$typeof: REACT_PROVIDER_TYPE,
                    _context: _context
                };
                {
                    var hasWarnedAboutUsingConsumer;
                    _context._currentRenderer = null;
                    _context._currentRenderer2 = null;
                    Object.defineProperties(_context, {
                        Consumer: {
                            get: function() {
                                if (!hasWarnedAboutUsingConsumer) {
                                    error('Consumer pattern is not supported by ReactServerContext');
                                    hasWarnedAboutUsingConsumer = true;
                                }
                                return null;
                            }
                        }
                    });
                }
                ContextRegistry[globalName] = _context;
            }
            var context = ContextRegistry[globalName];
            if (context._defaultValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                context._defaultValue = defaultValue;
                if (context._currentValue === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue = defaultValue;
                }
                if (context._currentValue2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    context._currentValue2 = defaultValue;
                }
            } else if (wasDefined) {
                throw new Error("ServerContext: " + globalName + " already defined");
            }
            return context;
        }
        function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
                ReactCurrentBatchConfig.transition._updatedFibers = new Set();
            }
            try {
                scope();
            } finally{
                ReactCurrentBatchConfig.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        currentTransition._updatedFibers.clear();
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                    }
                }
            }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
                try {
                    var requireString = ('require' + Math.random()).slice(0, 7);
                    var nodeRequire = module && module[requireString];
                    enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
                } catch (_err) {
                    enqueueTaskImpl = function(callback) {
                        {
                            if (didWarnAboutMessageChannel === false) {
                                didWarnAboutMessageChannel = true;
                                if (typeof MessageChannel === 'undefined') {
                                    error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
                                }
                            }
                        }
                        var channel = new MessageChannel();
                        channel.port1.onmessage = callback;
                        channel.port2.postMessage(undefined);
                    };
                }
            }
            return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
            {
                var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
                var prevActQueue = ReactCurrentActQueue.current;
                var prevActScopeDepth = actScopeDepth;
                actScopeDepth++;
                var queue = ReactCurrentActQueue.current = prevActQueue !== null ? prevActQueue : [];
                ReactCurrentActQueue.isBatchingLegacy = true;
                var result;
                var didAwaitActCall = false;
                try {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    result = callback();
                    var didScheduleLegacyUpdate = ReactCurrentActQueue.didScheduleLegacyUpdate;
                    if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {
                        flushActQueue(queue);
                    }
                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
                } catch (error) {
                    ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
                    popActScope(prevActQueue, prevActScopeDepth);
                    throw error;
                }
                if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
                    var thenable = result;
                    queueSeveralMicrotasks(function() {
                        if (!didAwaitActCall && !didWarnNoAwaitAct) {
                            didWarnNoAwaitAct = true;
                            error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
                        }
                    });
                    return {
                        then: function(resolve, reject) {
                            didAwaitActCall = true;
                            thenable.then(function(returnValue) {
                                popActScope(prevActQueue, prevActScopeDepth);
                                if (prevActScopeDepth === 0) {
                                    try {
                                        flushActQueue(queue);
                                        enqueueTask(function() {
                                            return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                        });
                                    } catch (error) {
                                        reject(error);
                                    }
                                } else {
                                    resolve(returnValue);
                                }
                            }, function(error) {
                                popActScope(prevActQueue, prevActScopeDepth);
                                reject(error);
                            });
                        }
                    };
                } else {
                    var returnValue = result;
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (prevActScopeDepth === 0) {
                        flushActQueue(queue);
                        if (queue.length !== 0) {
                            queueSeveralMicrotasks(function() {
                                if (!didAwaitActCall && !didWarnNoAwaitAct) {
                                    didWarnNoAwaitAct = true;
                                    error('A component suspended inside an `act` scope, but the ' + '`act` call was not awaited. When testing React ' + 'components that depend on asynchronous data, you must ' + 'await the result:\n\n' + 'await act(() => ...)');
                                }
                            });
                        }
                        ReactCurrentActQueue.current = null;
                    }
                    return {
                        then: function(resolve, reject) {
                            didAwaitActCall = true;
                            if (prevActScopeDepth === 0) {
                                ReactCurrentActQueue.current = queue;
                                enqueueTask(function() {
                                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                });
                            } else {
                                resolve(returnValue);
                            }
                        }
                    };
                }
            }
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
            {
                if (prevActScopeDepth !== actScopeDepth - 1) {
                    error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
                }
                actScopeDepth = prevActScopeDepth;
            }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                    if (queue.length !== 0) {
                        try {
                            flushActQueue(queue);
                            enqueueTask(function() {
                                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                            });
                        } catch (error) {
                            reject(error);
                        }
                    } else {
                        ReactCurrentActQueue.current = null;
                        resolve(returnValue);
                    }
                } else {
                    resolve(returnValue);
                }
            }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
            {
                if (!isFlushing) {
                    isFlushing = true;
                    var i = 0;
                    try {
                        for(; i < queue.length; i++){
                            var callback = queue[i];
                            do {
                                ReactCurrentActQueue.didUsePromise = false;
                                var continuation = callback(false);
                                if (continuation !== null) {
                                    if (ReactCurrentActQueue.didUsePromise) {
                                        queue[i] = callback;
                                        queue.splice(0, i);
                                        return;
                                    }
                                    callback = continuation;
                                } else {
                                    break;
                                }
                            }while (true)
                        }
                        queue.length = 0;
                    } catch (error) {
                        queue.splice(0, i + 1);
                        throw error;
                    } finally{
                        isFlushing = false;
                    }
                }
            }
        }
        var queueSeveralMicrotasks = typeof queueMicrotask === 'function' ? function(callback) {
            queueMicrotask(function() {
                return queueMicrotask(callback);
            });
        } : enqueueTask;
        var createElement = createElementWithValidation;
        var cloneElement = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray,
            only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cache = cache;
        exports.cloneElement = cloneElement;
        exports.createContext = createContext;
        exports.createElement = createElement;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.createServerContext = createServerContext;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.unstable_useCacheRefresh = useCacheRefresh;
        exports.use = use;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/cjs/react.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/get-segment-param.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getSegmentParam", {
    enumerable: true,
    get: function() {
        return getSegmentParam;
    }
});
const _interceptionroutes = __turbopack_require__("[project]/node_modules/next/dist/server/future/helpers/interception-routes.js (ecmascript, rsc)");
function getSegmentParam(segment) {
    const interceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((marker)=>segment.startsWith(marker));
    if (interceptionMarker) {
        segment = segment.slice(interceptionMarker.length);
    }
    if (segment.startsWith("[[...") && segment.endsWith("]]")) {
        return {
            type: "optional-catchall",
            param: segment.slice(5, -2)
        };
    }
    if (segment.startsWith("[...") && segment.endsWith("]")) {
        return {
            type: "catchall",
            param: segment.slice(4, -1)
        };
    }
    if (segment.startsWith("[") && segment.endsWith("]")) {
        return {
            type: "dynamic",
            param: segment.slice(1, -1)
        };
    }
    return null;
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/flight-render-result.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "FlightRenderResult", {
    enumerable: true,
    get: function() {
        return FlightRenderResult;
    }
});
const _approuterheaders = __turbopack_require__("[project]/node_modules/next/dist/client/components/app-router-headers.js (ecmascript, rsc)");
const _renderresult = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/server/render-result.js (ecmascript, rsc)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class FlightRenderResult extends _renderresult.default {
    constructor(response){
        super(response, {
            contentType: _approuterheaders.RSC_CONTENT_TYPE_HEADER
        });
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/action-handler.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "handleAction", {
    enumerable: true,
    get: function() {
        return handleAction;
    }
});
const _approuterheaders = __turbopack_require__("[project]/node_modules/next/dist/client/components/app-router-headers.js (ecmascript, rsc)");
const _notfound = __turbopack_require__("[project]/node_modules/next/dist/client/components/not-found.js (ecmascript, rsc)");
const _redirect = __turbopack_require__("[project]/node_modules/next/dist/client/components/redirect.js (ecmascript, rsc)");
const _renderresult = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/server/render-result.js (ecmascript, rsc)"));
const _flightrenderresult = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/flight-render-result.js (ecmascript, rsc)");
const _utils = __turbopack_require__("[project]/node_modules/next/dist/server/lib/server-ipc/utils.js (ecmascript, rsc)");
const _requestcookies = __turbopack_require__("[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js (ecmascript, rsc)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function nodeToWebReadableStream(nodeReadable) {
    if ("TURBOPACK compile-time truthy", 1) {
        const { Readable } = __turbopack_external_require__("stream");
        if ("toWeb" in Readable && typeof Readable.toWeb === "function") {
            return Readable.toWeb(nodeReadable);
        }
        return new ReadableStream({
            start (controller) {
                nodeReadable.on("data", (chunk)=>{
                    controller.enqueue(chunk);
                });
                nodeReadable.on("end", ()=>{
                    controller.close();
                });
                nodeReadable.on("error", (error)=>{
                    controller.error(error);
                });
            }
        });
    } else {
        "TURBOPACK unreachable";
    }
}
function formDataFromSearchQueryString(query) {
    const searchParams = new URLSearchParams(query);
    const formData = new FormData();
    for (const [key, value] of searchParams){
        formData.append(key, value);
    }
    return formData;
}
function nodeHeadersToRecord(headers) {
    const record = {};
    for (const [key, value] of Object.entries(headers)){
        if (value !== undefined) {
            record[key] = Array.isArray(value) ? value.join(", ") : `${value}`;
        }
    }
    return record;
}
function getForwardedHeaders(req, res) {
    const requestHeaders = req.headers;
    const requestCookies = requestHeaders["cookie"] ?? "";
    const responseHeaders = res.getHeaders();
    const rawSetCookies = responseHeaders["set-cookie"];
    const setCookies = (Array.isArray(rawSetCookies) ? rawSetCookies : [
        rawSetCookies
    ]).map((setCookie)=>{
        const [cookie] = `${setCookie}`.split(";");
        return cookie;
    });
    const mergedHeaders = (0, _utils.filterReqHeaders)({
        ...nodeHeadersToRecord(requestHeaders),
        ...nodeHeadersToRecord(responseHeaders)
    });
    const mergedCookies = requestCookies.split("; ").concat(setCookies).join("; ");
    mergedHeaders["cookie"] = mergedCookies;
    delete mergedHeaders["transfer-encoding"];
    return new Headers(mergedHeaders);
}
function fetchIPv4v6(url, init, v6 = false) {
    const hostname = url.hostname;
    if (!v6 && hostname === "localhost") {
        url.hostname = "127.0.0.1";
    }
    return fetch(url, init).catch((err)=>{
        if (err.code === "ECONNREFUSED" && !v6) {
            return fetchIPv4v6(url, init, true);
        }
        throw err;
    });
}
async function addRevalidationHeader(res, { staticGenerationStore, requestStore }) {
    var _staticGenerationStore_revalidatedTags;
    await Promise.all(staticGenerationStore.pendingRevalidates || []);
    const isTagRevalidated = ((_staticGenerationStore_revalidatedTags = staticGenerationStore.revalidatedTags) == null ? void 0 : _staticGenerationStore_revalidatedTags.length) ? 1 : 0;
    const isCookieRevalidated = (0, _requestcookies.getModifiedCookieValues)(requestStore.mutableCookies).length ? 1 : 0;
    res.setHeader("x-action-revalidated", JSON.stringify([
        [],
        isTagRevalidated,
        isCookieRevalidated
    ]));
}
async function createRedirectRenderResult(req, res, redirectUrl, staticGenerationStore) {
    res.setHeader("x-action-redirect", redirectUrl);
    if (redirectUrl.startsWith("/")) {
        var _staticGenerationStore_incrementalCache;
        const forwardedHeaders = getForwardedHeaders(req, res);
        forwardedHeaders.set(_approuterheaders.RSC, "1");
        const host = req.headers["host"];
        const proto = ((_staticGenerationStore_incrementalCache = staticGenerationStore.incrementalCache) == null ? void 0 : _staticGenerationStore_incrementalCache.requestProtocol) || "https";
        const fetchUrl = new URL(`${proto}://${host}${redirectUrl}`);
        if (staticGenerationStore.revalidatedTags) {
            var _staticGenerationStore_incrementalCache1, _staticGenerationStore_incrementalCache_prerenderManifest, _staticGenerationStore_incrementalCache_prerenderManifest_preview;
            forwardedHeaders.set("x-next-revalidated-tags", staticGenerationStore.revalidatedTags.join(","));
            forwardedHeaders.set("x-next-revalidate-tag-token", ((_staticGenerationStore_incrementalCache1 = staticGenerationStore.incrementalCache) == null ? void 0 : (_staticGenerationStore_incrementalCache_prerenderManifest = _staticGenerationStore_incrementalCache1.prerenderManifest) == null ? void 0 : (_staticGenerationStore_incrementalCache_prerenderManifest_preview = _staticGenerationStore_incrementalCache_prerenderManifest.preview) == null ? void 0 : _staticGenerationStore_incrementalCache_prerenderManifest_preview.previewModeId) || "");
        }
        try {
            const headResponse = await fetchIPv4v6(fetchUrl, {
                method: "HEAD",
                headers: forwardedHeaders,
                next: {
                    internal: 1
                }
            });
            if (headResponse.headers.get("content-type") === _approuterheaders.RSC_CONTENT_TYPE_HEADER) {
                const response = await fetchIPv4v6(fetchUrl, {
                    method: "GET",
                    headers: forwardedHeaders,
                    next: {
                        internal: 1
                    }
                });
                for (const [key, value] of response.headers){
                    if (!_utils.forbiddenHeaders.includes(key)) {
                        res.setHeader(key, value);
                    }
                }
                return new _flightrenderresult.FlightRenderResult(response.body);
            }
        } catch (err) {
            console.error(`failed to get redirect response`, err);
        }
    }
    return new _renderresult.default(JSON.stringify({}));
}
async function handleAction({ req, res, ComponentMod, pathname, serverActionsManifest, generateFlight, staticGenerationStore, requestStore, serverActionsBodySizeLimit }) {
    let actionId = req.headers[_approuterheaders.ACTION.toLowerCase()];
    const contentType = req.headers["content-type"];
    const isURLEncodedAction = req.method === "POST" && contentType === "application/x-www-form-urlencoded";
    const isMultipartAction = req.method === "POST" && (contentType == null ? void 0 : contentType.startsWith("multipart/form-data"));
    const isFetchAction = actionId !== undefined && typeof actionId === "string" && req.method === "POST";
    if (isFetchAction || isURLEncodedAction || isMultipartAction) {
        let bound = [];
        const workerName = "app" + pathname;
        const serverModuleMap = new Proxy({}, {
            get: (_, id)=>{
                return {
                    id: serverActionsManifest[process.env.NEXT_RUNTIME === "edge" ? "edge" : "node"][id].workers[workerName],
                    name: id,
                    chunks: []
                };
            }
        });
        const { actionAsyncStorage } = ComponentMod;
        let actionResult;
        try {
            await actionAsyncStorage.run({
                isAction: true
            }, async ()=>{
                if ("TURBOPACK compile-time falsy", 0) {
                    "TURBOPACK unreachable";
                } else {
                    const { decodeReply, decodeReplyFromBusboy, decodeAction } = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-webpack/server.node.js (ecmascript, rsc)");
                    if (isMultipartAction) {
                        if (isFetchAction) {
                            const busboy = __turbopack_require__("[project]/node_modules/busboy/lib/index.js (ecmascript, rsc)");
                            const bb = busboy({
                                headers: req.headers
                            });
                            req.pipe(bb);
                            bound = await decodeReplyFromBusboy(bb, serverModuleMap);
                        } else {
                            const UndiciRequest = __turbopack_require__("[project]/node_modules/next/dist/compiled/undici/index.js (ecmascript, rsc)").Request;
                            const fakeRequest = new UndiciRequest("http://localhost", {
                                method: "POST",
                                headers: {
                                    "Content-Type": req.headers["content-type"]
                                },
                                body: nodeToWebReadableStream(req),
                                duplex: "half"
                            });
                            const formData = await fakeRequest.formData();
                            const action = await decodeAction(formData, serverModuleMap);
                            await action();
                            return;
                        }
                    } else {
                        const { parseBody } = __turbopack_require__("[project]/node_modules/next/dist/server/api-utils/node.js (ecmascript, rsc)");
                        let actionData;
                        try {
                            actionData = await parseBody(req, serverActionsBodySizeLimit ?? "1mb") || "";
                        } catch (e) {
                            if (e && e.statusCode === 413) {
                                e.message = e.message + "\nTo configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions#size-limitation";
                            }
                            throw e;
                        }
                        if (isURLEncodedAction) {
                            const formData = formDataFromSearchQueryString(actionData);
                            bound = await decodeReply(formData, serverModuleMap);
                        } else {
                            bound = await decodeReply(actionData, serverModuleMap);
                        }
                    }
                }
                const actionModId = serverActionsManifest[process.env.NEXT_RUNTIME === "edge" ? "edge" : "node"][actionId].workers[workerName];
                const actionHandler = ComponentMod.__next_app__.require(actionModId)[actionId];
                const returnVal = await actionHandler.apply(null, bound);
                if (isFetchAction) {
                    await addRevalidationHeader(res, {
                        staticGenerationStore,
                        requestStore
                    });
                    actionResult = await generateFlight({
                        actionResult: Promise.resolve(returnVal),
                        skipFlight: !staticGenerationStore.pathWasRevalidated
                    });
                }
            });
            return actionResult;
        } catch (err) {
            if ((0, _redirect.isRedirectError)(err)) {
                const redirectUrl = (0, _redirect.getURLFromRedirectError)(err);
                await addRevalidationHeader(res, {
                    staticGenerationStore,
                    requestStore
                });
                if (isFetchAction) {
                    return createRedirectRenderResult(req, res, redirectUrl, staticGenerationStore);
                }
                if (err.mutableCookies) {
                    const headers = new Headers();
                    if ((0, _requestcookies.appendMutableCookies)(headers, err.mutableCookies)) {
                        res.setHeader("set-cookie", Array.from(headers.values()));
                    }
                }
                res.setHeader("Location", redirectUrl);
                res.statusCode = 303;
                return new _renderresult.default("");
            } else if ((0, _notfound.isNotFoundError)(err)) {
                res.statusCode = 404;
                await addRevalidationHeader(res, {
                    staticGenerationStore,
                    requestStore
                });
                if (isFetchAction) {
                    const promise = Promise.reject(err);
                    try {
                        await promise;
                    } catch (_) {}
                    return generateFlight({
                        skipFlight: false,
                        actionResult: promise,
                        asNotFound: true
                    });
                }
                return "not-found";
            }
            if (isFetchAction) {
                res.statusCode = 500;
                await Promise.all(staticGenerationStore.pendingRevalidates || []);
                const promise = Promise.reject(err);
                try {
                    await promise;
                } catch (_) {}
                return generateFlight({
                    actionResult: promise,
                    skipFlight: !staticGenerationStore.pathWasRevalidated
                });
            }
            throw err;
        }
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/create-flight-router-state-from-loader-tree.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    addSearchParamsIfPageSegment: null,
    createFlightRouterStateFromLoaderTree: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    addSearchParamsIfPageSegment: function() {
        return addSearchParamsIfPageSegment;
    },
    createFlightRouterStateFromLoaderTree: function() {
        return createFlightRouterStateFromLoaderTree;
    }
});
const _constants = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/constants.js (ecmascript, rsc)");
function addSearchParamsIfPageSegment(segment, searchParams) {
    const isPageSegment = segment === _constants.PAGE_SEGMENT_KEY;
    if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== "{}" ? segment + "?" + stringifiedQuery : segment;
    }
    return segment;
}
function createFlightRouterStateFromLoaderTree([segment, parallelRoutes, { layout }], getDynamicParamFromSegment, searchParams, rootLayoutIncluded = false) {
    const dynamicParam = getDynamicParamFromSegment(segment);
    const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment;
    const segmentTree = [
        addSearchParamsIfPageSegment(treeSegment, searchParams),
        {}
    ];
    if (!rootLayoutIncluded && typeof layout !== "undefined") {
        rootLayoutIncluded = true;
        segmentTree[4] = true;
    }
    segmentTree[1] = Object.keys(parallelRoutes).reduce((existingValue, currentValue)=>{
        existingValue[currentValue] = createFlightRouterStateFromLoaderTree(parallelRoutes[currentValue], getDynamicParamFromSegment, searchParams, rootLayoutIncluded);
        return existingValue;
    }, {});
    return segmentTree;
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/validate-url.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "validateURL", {
    enumerable: true,
    get: function() {
        return validateURL;
    }
});
const DUMMY_ORIGIN = "http://n";
const INVALID_URL_MESSAGE = "Invalid request URL";
function validateURL(url) {
    if (!url) {
        throw new Error(INVALID_URL_MESSAGE);
    }
    try {
        const parsed = new URL(url, DUMMY_ORIGIN);
        if (parsed.origin !== DUMMY_ORIGIN) {
            throw new Error(INVALID_URL_MESSAGE);
        }
        return url;
    } catch  {
        throw new Error(INVALID_URL_MESSAGE);
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/types.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "flightRouterStateSchema", {
    enumerable: true,
    get: function() {
        return flightRouterStateSchema;
    }
});
const _zod = _interop_require_default(__turbopack_require__("[project]/node_modules/zod/lib/index.js (ecmascript, rsc)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const dynamicParamTypesSchema = _zod.default.enum([
    "c",
    "oc",
    "d"
]);
const segmentSchema = _zod.default.union([
    _zod.default.string(),
    _zod.default.tuple([
        _zod.default.string(),
        _zod.default.string(),
        dynamicParamTypesSchema
    ])
]);
const flightRouterStateSchema = _zod.default.lazy(()=>{
    const parallelRoutesSchema = _zod.default.record(flightRouterStateSchema);
    const urlSchema = _zod.default.string().nullable().optional();
    const refreshSchema = _zod.default.literal("refetch").nullable().optional();
    const isRootLayoutSchema = _zod.default.boolean().optional();
    return _zod.default.union([
        _zod.default.tuple([
            segmentSchema,
            parallelRoutesSchema,
            urlSchema,
            refreshSchema,
            isRootLayoutSchema
        ]),
        _zod.default.tuple([
            segmentSchema,
            parallelRoutesSchema,
            urlSchema,
            refreshSchema
        ]),
        _zod.default.tuple([
            segmentSchema,
            parallelRoutesSchema,
            urlSchema
        ]),
        _zod.default.tuple([
            segmentSchema,
            parallelRoutesSchema
        ])
    ]);
});

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/parse-and-validate-flight-router-state.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parseAndValidateFlightRouterState", {
    enumerable: true,
    get: function() {
        return parseAndValidateFlightRouterState;
    }
});
const _types = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/types.js (ecmascript, rsc)");
function parseAndValidateFlightRouterState(stateHeader) {
    if (typeof stateHeader === "undefined") {
        return undefined;
    }
    if (Array.isArray(stateHeader)) {
        throw new Error("Multiple router state headers were sent. This is not allowed.");
    }
    if (stateHeader.length > 20 * 2000) {
        throw new Error("The router state header was too large.");
    }
    try {
        return _types.flightRouterStateSchema.parse(JSON.parse(decodeURIComponent(stateHeader)));
    } catch  {
        throw new Error("The router state header was sent but could not be parsed.");
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/render-to-string.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "renderToString", {
    enumerable: true,
    get: function() {
        return renderToString;
    }
});
const _nodewebstreamshelper = __turbopack_require__("[project]/node_modules/next/dist/server/stream-utils/node-web-streams-helper.js (ecmascript, rsc)");
const _constants = __turbopack_require__("[project]/node_modules/next/dist/server/lib/trace/constants.js (ecmascript, rsc)");
const _tracer = __turbopack_require__("[project]/node_modules/next/dist/server/lib/trace/tracer.js (ecmascript, rsc)");
async function renderToString({ ReactDOMServer, element }) {
    return (0, _tracer.getTracer)().trace(_constants.AppRenderSpan.renderToString, async ()=>{
        const renderStream = await ReactDOMServer.renderToReadableStream(element);
        await renderStream.allReady;
        return (0, _nodewebstreamshelper.streamToString)(renderStream);
    });
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/get-script-nonce-from-header.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getScriptNonceFromHeader", {
    enumerable: true,
    get: function() {
        return getScriptNonceFromHeader;
    }
});
const _htmlescape = __turbopack_require__("[project]/node_modules/next/dist/server/htmlescape.js (ecmascript, rsc)");
function getScriptNonceFromHeader(cspHeaderValue) {
    var _directive_split_slice_map_find;
    const directives = cspHeaderValue.split(";").map((directive)=>directive.trim());
    const directive = directives.find((dir)=>dir.startsWith("script-src")) || directives.find((dir)=>dir.startsWith("default-src"));
    if (!directive) {
        return;
    }
    const nonce = (_directive_split_slice_map_find = directive.split(" ").slice(1).map((source)=>source.trim()).find((source)=>source.startsWith("'nonce-") && source.length > 8 && source.endsWith("'"))) == null ? void 0 : _directive_split_slice_map_find.slice(7, -1);
    if (!nonce) {
        return;
    }
    if (_htmlescape.ESCAPE_REGEX.test(nonce)) {
        throw new Error("Nonce value from Content-Security-Policy contained HTML escape characters.\nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters");
    }
    return nonce;
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/get-preloadable-fonts.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getPreloadableFonts", {
    enumerable: true,
    get: function() {
        return getPreloadableFonts;
    }
});
function getPreloadableFonts(nextFontManifest, filePath, injectedFontPreloadTags) {
    if (!nextFontManifest || !filePath) {
        return null;
    }
    const filepathWithoutExtension = filePath.replace(/\.[^.]+$/, "");
    const fontFiles = new Set();
    let foundFontUsage = false;
    const preloadedFontFiles = nextFontManifest.app[filepathWithoutExtension];
    if (preloadedFontFiles) {
        foundFontUsage = true;
        for (const fontFile of preloadedFontFiles){
            if (!injectedFontPreloadTags.has(fontFile)) {
                fontFiles.add(fontFile);
                injectedFontPreloadTags.add(fontFile);
            }
        }
    }
    if (fontFiles.size) {
        return [
            ...fontFiles
        ].sort();
    } else if (foundFontUsage && injectedFontPreloadTags.size === 0) {
        return [];
    } else {
        return null;
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/get-css-inlined-link-tags.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getCssInlinedLinkTags", {
    enumerable: true,
    get: function() {
        return getCssInlinedLinkTags;
    }
});
function getCssInlinedLinkTags(clientReferenceManifest, filePath, injectedCSS, collectNewCSSImports) {
    const filePathWithoutExt = filePath.replace(/\.[^.]+$/, "");
    const chunks = new Set();
    const entryCSSFiles = clientReferenceManifest.entryCSSFiles[filePathWithoutExt];
    if (entryCSSFiles) {
        for (const file of entryCSSFiles){
            if (!injectedCSS.has(file)) {
                if (collectNewCSSImports) {
                    injectedCSS.add(file);
                }
                chunks.add(file);
            }
        }
    }
    return [
        ...chunks
    ];
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/get-short-dynamic-param-type.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    dynamicParamTypes: null,
    getShortDynamicParamType: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    dynamicParamTypes: function() {
        return dynamicParamTypes;
    },
    getShortDynamicParamType: function() {
        return getShortDynamicParamType;
    }
});
const dynamicParamTypes = {
    catchall: "c",
    "optional-catchall": "oc",
    dynamic: "d"
};
function getShortDynamicParamType(type) {
    const short = dynamicParamTypes[type];
    if (!short) {
        throw new Error("Unknown dynamic param type");
    }
    return short;
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/create-error-handler.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createErrorHandler", {
    enumerable: true,
    get: function() {
        return createErrorHandler;
    }
});
const _hooksservercontext = __turbopack_require__("[project]/node_modules/next/dist/client/components/hooks-server-context.js (ecmascript, rsc)");
const _stringhash = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/compiled/string-hash/index.js (ecmascript, rsc)"));
const _formatservererror = __turbopack_require__("[project]/node_modules/next/dist/lib/format-server-error.js (ecmascript, rsc)");
const _notfound = __turbopack_require__("[project]/node_modules/next/dist/client/components/not-found.js (ecmascript, rsc)");
const _redirect = __turbopack_require__("[project]/node_modules/next/dist/client/components/redirect.js (ecmascript, rsc)");
const _nossrerror = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/no-ssr-error.js (ecmascript, rsc)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function createErrorHandler({ _source, dev, isNextExport, errorLogger, capturedErrors, allCapturedErrors }) {
    return (err)=>{
        var _err_message;
        if (allCapturedErrors) allCapturedErrors.push(err);
        if (err && (err.digest === _hooksservercontext.DYNAMIC_ERROR_CODE || (0, _notfound.isNotFoundError)(err) || err.digest === _nossrerror.NEXT_DYNAMIC_NO_SSR_CODE || (0, _redirect.isRedirectError)(err))) {
            return err.digest;
        }
        if (dev) {
            (0, _formatservererror.formatServerError)(err);
        }
        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes("The specific message is omitted in production builds to avoid leaking sensitive details.")))) {
            if (errorLogger) {
                errorLogger(err).catch(()=>{});
            } else {
                if ("TURBOPACK compile-time truthy", 1) {
                    const { logAppDirError } = __turbopack_require__("[project]/node_modules/next/dist/server/dev/log-app-dir-error.js (ecmascript, rsc)");
                    logAppDirError(err);
                }
                if ("TURBOPACK compile-time falsy", 0) {
                    "TURBOPACK unreachable";
                }
            }
        }
        capturedErrors.push(err);
        return (0, _stringhash.default)(err.message + err.stack + (err.digest || "")).toString();
    };
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/preload-component.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "preloadComponent", {
    enumerable: true,
    get: function() {
        return preloadComponent;
    }
});
function preloadComponent(Component, props) {
    const prev = console.error;
    console.error = function(msg) {
        if (msg.startsWith("Warning: Invalid hook call.")) {} else {
            prev.apply(console, arguments);
        }
    };
    try {
        let result = Component(props);
        if (result && typeof result.then === "function") {
            result.then(()=>{}, ()=>{});
        }
        return function() {
            return result;
        };
    } catch (x) {} finally{
        console.error = prev;
    }
    return Component;
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/interop-default.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "interopDefault", {
    enumerable: true,
    get: function() {
        return interopDefault;
    }
});
function interopDefault(mod) {
    return mod.default || mod;
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/use-flight-response.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useFlightResponse", {
    enumerable: true,
    get: function() {
        return useFlightResponse;
    }
});
const _nodewebstreamshelper = __turbopack_require__("[project]/node_modules/next/dist/server/stream-utils/node-web-streams-helper.js (ecmascript, rsc)");
const _encodedecode = __turbopack_require__("[project]/node_modules/next/dist/server/stream-utils/encode-decode.js (ecmascript, rsc)");
const _htmlescape = __turbopack_require__("[project]/node_modules/next/dist/server/htmlescape.js (ecmascript, rsc)");
const isEdgeRuntime = process.env.NEXT_RUNTIME === "edge";
function useFlightResponse(writable, req, clientReferenceManifest, rscChunks, flightResponseRef, nonce) {
    if (flightResponseRef.current !== null) {
        return flightResponseRef.current;
    }
    const { createFromReadableStream } = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-webpack/client.edge.js (ecmascript, rsc)");
    const [renderStream, forwardStream] = (0, _nodewebstreamshelper.readableStreamTee)(req);
    const res = createFromReadableStream(renderStream, {
        moduleMap: isEdgeRuntime ? clientReferenceManifest.edgeSSRModuleMapping : clientReferenceManifest.ssrModuleMapping
    });
    flightResponseRef.current = res;
    let bootstrapped = false;
    const forwardReader = forwardStream.getReader();
    const writer = writable.getWriter();
    const startScriptTag = nonce ? `<script nonce=${JSON.stringify(nonce)}>` : "<script>";
    const textDecoder = new TextDecoder();
    function read() {
        forwardReader.read().then(({ done, value })=>{
            if (value) {
                rscChunks.push(value);
            }
            if (!bootstrapped) {
                bootstrapped = true;
                writer.write((0, _encodedecode.encodeText)(`${startScriptTag}(self.__next_f=self.__next_f||[]).push(${(0, _htmlescape.htmlEscapeJsonString)(JSON.stringify([
                    0
                ]))})</script>`));
            }
            if (done) {
                setTimeout(()=>{
                    flightResponseRef.current = null;
                });
                writer.close();
            } else {
                const responsePartial = (0, _encodedecode.decodeText)(value, textDecoder);
                const scripts = `${startScriptTag}self.__next_f.push(${(0, _htmlescape.htmlEscapeJsonString)(JSON.stringify([
                    1,
                    responsePartial
                ]))})</script>`;
                writer.write((0, _encodedecode.encodeText)(scripts));
                read();
            }
        });
    }
    read();
    return res;
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/create-server-components-renderer.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createServerComponentRenderer", {
    enumerable: true,
    get: function() {
        return createServerComponentRenderer;
    }
});
const _react = _interop_require_wildcard(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, rsc)"));
const _useflightresponse = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/use-flight-response.js (ecmascript, rsc)");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function createServerComponentRenderer(ComponentToRender, ComponentMod, { transformStream, clientReferenceManifest, serverContexts, rscChunks }, serverComponentsErrorHandler, nonce) {
    if (ComponentMod.__next_app__) {
        globalThis.__next_require__ = ComponentMod.__next_app__.require;
        globalThis.__next_chunk_load__ = ComponentMod.__next_app__.loadChunk;
    }
    let RSCStream;
    const createRSCStream = (props)=>{
        if (!RSCStream) {
            RSCStream = ComponentMod.renderToReadableStream(_react.default.createElement(ComponentToRender, props), clientReferenceManifest.clientModules, {
                context: serverContexts,
                onError: serverComponentsErrorHandler
            });
        }
        return RSCStream;
    };
    const flightResponseRef = {
        current: null
    };
    const writable = transformStream.writable;
    return function ServerComponentWrapper(props) {
        const reqStream = createRSCStream(props);
        const response = (0, _useflightresponse.useFlightResponse)(writable, reqStream, clientReferenceManifest, rscChunks, flightResponseRef, nonce);
        return (0, _react.use)(response);
    };
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/app-render.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "renderToHTMLOrFlight", {
    enumerable: true,
    get: function() {
        return renderToHTMLOrFlight;
    }
});
const _react = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, rsc)"));
const _error = __turbopack_require__("[project]/node_modules/next/dist/client/components/error.js (ecmascript, rsc)");
const _createservercomponentsrenderer = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/create-server-components-renderer.js (ecmascript, rsc)");
const _renderresult = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/server/render-result.js (ecmascript, rsc)"));
const _nodewebstreamshelper = __turbopack_require__("[project]/node_modules/next/dist/server/stream-utils/node-web-streams-helper.js (ecmascript, rsc)");
const _matchsegments = __turbopack_require__("[project]/node_modules/next/dist/client/components/match-segments.js (ecmascript, rsc)");
const _serverinsertedhtml = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/server-inserted-html.js (ecmascript, rsc)");
const _internalutils = __turbopack_require__("[project]/node_modules/next/dist/server/internal-utils.js (ecmascript, rsc)");
const _approuterheaders = __turbopack_require__("[project]/node_modules/next/dist/client/components/app-router-headers.js (ecmascript, rsc)");
const _metadata = __turbopack_require__("[project]/node_modules/next/dist/lib/metadata/metadata.js (ecmascript, rsc)");
const _requestasyncstoragewrapper = __turbopack_require__("[project]/node_modules/next/dist/server/async-storage/request-async-storage-wrapper.js (ecmascript, rsc)");
const _staticgenerationasyncstoragewrapper = __turbopack_require__("[project]/node_modules/next/dist/server/async-storage/static-generation-async-storage-wrapper.js (ecmascript, rsc)");
const _clientreference = __turbopack_require__("[project]/node_modules/next/dist/lib/client-reference.js (ecmascript, rsc)");
const _appdirmodule = __turbopack_require__("[project]/node_modules/next/dist/server/lib/app-dir-module.js (ecmascript, rsc)");
const _notfound = __turbopack_require__("[project]/node_modules/next/dist/client/components/not-found.js (ecmascript, rsc)");
const _redirect = __turbopack_require__("[project]/node_modules/next/dist/client/components/redirect.js (ecmascript, rsc)");
const _patchfetch = __turbopack_require__("[project]/node_modules/next/dist/server/lib/patch-fetch.js (ecmascript, rsc)");
const _constants = __turbopack_require__("[project]/node_modules/next/dist/server/lib/trace/constants.js (ecmascript, rsc)");
const _tracer = __turbopack_require__("[project]/node_modules/next/dist/server/lib/trace/tracer.js (ecmascript, rsc)");
const _interopdefault = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/interop-default.js (ecmascript, rsc)");
const _preloadcomponent = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/preload-component.js (ecmascript, rsc)");
const _flightrenderresult = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/flight-render-result.js (ecmascript, rsc)");
const _createerrorhandler = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/create-error-handler.js (ecmascript, rsc)");
const _getshortdynamicparamtype = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/get-short-dynamic-param-type.js (ecmascript, rsc)");
const _getsegmentparam = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/get-segment-param.js (ecmascript, rsc)");
const _getcssinlinedlinktags = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/get-css-inlined-link-tags.js (ecmascript, rsc)");
const _getpreloadablefonts = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/get-preloadable-fonts.js (ecmascript, rsc)");
const _getscriptnoncefromheader = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/get-script-nonce-from-header.js (ecmascript, rsc)");
const _rendertostring = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/render-to-string.js (ecmascript, rsc)");
const _parseandvalidateflightrouterstate = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/parse-and-validate-flight-router-state.js (ecmascript, rsc)");
const _validateurl = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/validate-url.js (ecmascript, rsc)");
const _createflightrouterstatefromloadertree = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/create-flight-router-state-from-loader-tree.js (ecmascript, rsc)");
const _actionhandler = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/action-handler.js (ecmascript, rsc)");
const _nossrerror = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/no-ssr-error.js (ecmascript, rsc)");
const _log = __turbopack_require__("[project]/node_modules/next/dist/build/output/log.js (ecmascript, rsc)");
const _requestcookies = __turbopack_require__("[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js (ecmascript, rsc)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function ErrorHtml({ children }) {
    return _react.default.createElement("html", {
        id: "__next_error__"
    }, _react.default.createElement("body", null, children));
}
function findMatchedComponent(loaderTree, componentType, depth, result) {
    const [, parallelRoutes, components] = loaderTree;
    const childKeys = Object.keys(parallelRoutes);
    result = components[componentType] || result;
    if (depth <= 0 || childKeys.length === 0) {
        return result;
    }
    for (const key of childKeys){
        const childTree = parallelRoutes[key];
        const matchedComponent = findMatchedComponent(childTree, componentType, depth - 1, result);
        if (matchedComponent) {
            return matchedComponent;
        }
    }
    return undefined;
}
function findDynamicParamFromRouterState(providedFlightRouterState, segment) {
    if (!providedFlightRouterState) {
        return null;
    }
    const treeSegment = providedFlightRouterState[0];
    if ((0, _matchsegments.canSegmentBeOverridden)(segment, treeSegment)) {
        if (!Array.isArray(treeSegment) || Array.isArray(segment)) {
            return null;
        }
        return {
            param: treeSegment[0],
            value: treeSegment[1],
            treeSegment: treeSegment,
            type: treeSegment[2]
        };
    }
    for (const parallelRouterState of Object.values(providedFlightRouterState[1])){
        const maybeDynamicParam = findDynamicParamFromRouterState(parallelRouterState, segment);
        if (maybeDynamicParam) {
            return maybeDynamicParam;
        }
    }
    return null;
}
function hasLoadingComponentInTree(tree) {
    const [, parallelRoutes, { loading }] = tree;
    if (loading) {
        return true;
    }
    return Object.values(parallelRoutes).some((parallelRoute)=>hasLoadingComponentInTree(parallelRoute));
}
async function renderToHTMLOrFlight(req, res, pagePath, query, renderOpts) {
    const isFlight = req.headers[_approuterheaders.RSC.toLowerCase()] !== undefined;
    const pathname = (0, _validateurl.validateURL)(req.url);
    const { buildManifest, subresourceIntegrityManifest, serverActionsManifest, ComponentMod, dev, nextFontManifest, supportsDynamicHTML, nextConfigOutput, serverActionsBodySizeLimit } = renderOpts;
    const appUsingSizeAdjust = !!(nextFontManifest == null ? void 0 : nextFontManifest.appUsingSizeAdjust);
    const clientReferenceManifest = renderOpts.clientReferenceManifest;
    const capturedErrors = [];
    const allCapturedErrors = [];
    const isNextExport = !!renderOpts.nextExport;
    const serverComponentsErrorHandler = (0, _createerrorhandler.createErrorHandler)({
        _source: "serverComponentsRenderer",
        dev,
        isNextExport,
        errorLogger: renderOpts.appDirDevErrorLogger,
        capturedErrors
    });
    const flightDataRendererErrorHandler = (0, _createerrorhandler.createErrorHandler)({
        _source: "flightDataRenderer",
        dev,
        isNextExport,
        errorLogger: renderOpts.appDirDevErrorLogger,
        capturedErrors
    });
    const htmlRendererErrorHandler = (0, _createerrorhandler.createErrorHandler)({
        _source: "htmlRenderer",
        dev,
        isNextExport,
        errorLogger: renderOpts.appDirDevErrorLogger,
        capturedErrors,
        allCapturedErrors
    });
    (0, _patchfetch.patchFetch)(ComponentMod);
    const generateStaticHTML = supportsDynamicHTML !== true;
    const staticGenerationAsyncStorage = ComponentMod.staticGenerationAsyncStorage;
    const requestAsyncStorage = ComponentMod.requestAsyncStorage;
    const staticGenerationBailout = ComponentMod.staticGenerationBailout;
    const wrappedRender = async ()=>{
        var _getTracer_getRootSpanAttributes, _staticGenerationStore_tags;
        const staticGenerationStore = staticGenerationAsyncStorage.getStore();
        if (!staticGenerationStore) {
            throw new Error(`Invariant: Render expects to have staticGenerationAsyncStorage, none found`);
        }
        staticGenerationStore.fetchMetrics = [];
        renderOpts.fetchMetrics = staticGenerationStore.fetchMetrics;
        const requestStore = requestAsyncStorage.getStore();
        if (!requestStore) {
            throw new Error(`Invariant: Render expects to have requestAsyncStorage, none found`);
        }
        query = {
            ...query
        };
        (0, _internalutils.stripInternalQueries)(query);
        const isPrefetch = req.headers[_approuterheaders.NEXT_ROUTER_PREFETCH.toLowerCase()] !== undefined;
        let providedFlightRouterState = isFlight ? (0, _parseandvalidateflightrouterstate.parseAndValidateFlightRouterState)(req.headers[_approuterheaders.NEXT_ROUTER_STATE_TREE.toLowerCase()]) : undefined;
        const loaderTree = ComponentMod.tree;
        const requestId = process.env.NEXT_RUNTIME === "edge" ? crypto.randomUUID() : __turbopack_require__("[project]/node_modules/next/dist/compiled/nanoid/index.cjs (ecmascript, rsc)").nanoid();
        const LayoutRouter = ComponentMod.LayoutRouter;
        const RenderFromTemplateContext = ComponentMod.RenderFromTemplateContext;
        const createSearchParamsBailoutProxy = ComponentMod.createSearchParamsBailoutProxy;
        const StaticGenerationSearchParamsBailoutProvider = ComponentMod.StaticGenerationSearchParamsBailoutProvider;
        const isStaticGeneration = staticGenerationStore.isStaticGeneration;
        const providedSearchParams = isStaticGeneration ? createSearchParamsBailoutProxy() : query;
        const searchParamsProps = {
            searchParams: providedSearchParams
        };
        const serverContexts = [
            [
                "WORKAROUND",
                null
            ]
        ];
        const pathParams = renderOpts.params;
        const getDynamicParamFromSegment = (segment)=>{
            const segmentParam = (0, _getsegmentparam.getSegmentParam)(segment);
            if (!segmentParam) {
                return null;
            }
            const key = segmentParam.param;
            let value = pathParams[key];
            if (value === "__NEXT_EMPTY_PARAM__") {
                value = undefined;
            }
            if (Array.isArray(value)) {
                value = value.map((i)=>encodeURIComponent(i));
            } else if (typeof value === "string") {
                value = encodeURIComponent(value);
            }
            if (!value) {
                if (segmentParam.type === "optional-catchall") {
                    const type = _getshortdynamicparamtype.dynamicParamTypes[segmentParam.type];
                    return {
                        param: key,
                        value: null,
                        type: type,
                        treeSegment: [
                            key,
                            "",
                            type
                        ]
                    };
                }
                return findDynamicParamFromRouterState(providedFlightRouterState, segment);
            }
            const type = (0, _getshortdynamicparamtype.getShortDynamicParamType)(segmentParam.type);
            return {
                param: key,
                value: value,
                treeSegment: [
                    key,
                    Array.isArray(value) ? value.join("/") : value,
                    type
                ],
                type: type
            };
        };
        let defaultRevalidate = false;
        const assetPrefix = renderOpts.assetPrefix || "";
        const getAssetQueryString = (addTimestamp)=>{
            const isDev = process.env.NODE_ENV === "development";
            let qs = "";
            if (isDev && addTimestamp) {
                qs += `?v=${Date.now()}`;
            }
            if (renderOpts.deploymentId) {
                qs += `${isDev ? "&" : "?"}dpl=${renderOpts.deploymentId}`;
            }
            return qs;
        };
        const createComponentAndStyles = async ({ filePath, getComponent, shouldPreload, injectedCSS })=>{
            const cssHrefs = (0, _getcssinlinedlinktags.getCssInlinedLinkTags)(clientReferenceManifest, filePath, injectedCSS);
            const styles = cssHrefs ? cssHrefs.map((href, index)=>{
                const fullHref = `${assetPrefix}/_next/${href}${getAssetQueryString(true)}`;
                const precedence = shouldPreload ? process.env.NODE_ENV === "development" ? "next_" + href : "next" : undefined;
                return _react.default.createElement("link", {
                    rel: "stylesheet",
                    href: fullHref,
                    precedence: precedence,
                    key: index
                });
            }) : null;
            const Comp = (0, _interopdefault.interopDefault)(await getComponent());
            return [
                Comp,
                styles
            ];
        };
        const getLayerAssets = ({ layoutOrPagePath, injectedCSS: injectedCSSWithCurrentLayout, injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout })=>{
            const stylesheets = layoutOrPagePath ? (0, _getcssinlinedlinktags.getCssInlinedLinkTags)(clientReferenceManifest, layoutOrPagePath, injectedCSSWithCurrentLayout, true) : [];
            const preloadedFontFiles = layoutOrPagePath ? (0, _getpreloadablefonts.getPreloadableFonts)(nextFontManifest, layoutOrPagePath, injectedFontPreloadTagsWithCurrentLayout) : null;
            if (preloadedFontFiles) {
                if (preloadedFontFiles.length) {
                    for(let i = 0; i < preloadedFontFiles.length; i++){
                        const fontFilename = preloadedFontFiles[i];
                        const ext = /\.(woff|woff2|eot|ttf|otf)$/.exec(fontFilename)[1];
                        const type = `font/${ext}`;
                        const href = `${assetPrefix}/_next/${fontFilename}`;
                        ComponentMod.preloadFont(href, type);
                    }
                } else {
                    try {
                        let url = new URL(assetPrefix);
                        ComponentMod.preconnect(url.origin, "anonymous");
                    } catch (error) {
                        ComponentMod.preconnect("/", "anonymous");
                    }
                }
            }
            const styles = stylesheets ? stylesheets.map((href, index)=>{
                const fullHref = `${assetPrefix}/_next/${href}${getAssetQueryString(true)}`;
                const precedence = process.env.NODE_ENV === "development" ? "next_" + href : "next";
                ComponentMod.preloadStyle(fullHref);
                return _react.default.createElement("link", {
                    rel: "stylesheet",
                    href: fullHref,
                    precedence: precedence,
                    key: index
                });
            }) : null;
            return styles;
        };
        const parseLoaderTree = (tree)=>{
            const [segment, parallelRoutes, components] = tree;
            const { layout } = components;
            let { page } = components;
            page = segment === "__DEFAULT__" ? components.defaultPage : page;
            const layoutOrPagePath = (layout == null ? void 0 : layout[1]) || (page == null ? void 0 : page[1]);
            return {
                page,
                segment,
                components,
                layoutOrPagePath,
                parallelRoutes
            };
        };
        const createComponentTree = async ({ createSegmentPath, loaderTree: tree, parentParams, firstItem, rootLayoutIncluded, injectedCSS, injectedFontPreloadTags, asNotFound })=>{
            const { page, layoutOrPagePath, segment, components, parallelRoutes } = parseLoaderTree(tree);
            const { layout, template, error, loading, "not-found": notFound } = components;
            const injectedCSSWithCurrentLayout = new Set(injectedCSS);
            const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);
            const styles = getLayerAssets({
                layoutOrPagePath,
                injectedCSS: injectedCSSWithCurrentLayout,
                injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout
            });
            const [Template, templateStyles] = template ? await createComponentAndStyles({
                filePath: template[1],
                getComponent: template[0],
                shouldPreload: true,
                injectedCSS: injectedCSSWithCurrentLayout
            }) : [
                _react.default.Fragment
            ];
            const [ErrorComponent, errorStyles] = error ? await createComponentAndStyles({
                filePath: error[1],
                getComponent: error[0],
                injectedCSS: injectedCSSWithCurrentLayout
            }) : [];
            const [Loading, loadingStyles] = loading ? await createComponentAndStyles({
                filePath: loading[1],
                getComponent: loading[0],
                injectedCSS: injectedCSSWithCurrentLayout
            }) : [];
            const isLayout = typeof layout !== "undefined";
            const isPage = typeof page !== "undefined";
            const [layoutOrPageMod] = await (0, _appdirmodule.getLayoutOrPageModule)(tree);
            const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
            const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
            const [NotFound, notFoundStyles] = notFound ? await createComponentAndStyles({
                filePath: notFound[1],
                getComponent: notFound[0],
                injectedCSS: injectedCSSWithCurrentLayout
            }) : [];
            let dynamic = layoutOrPageMod == null ? void 0 : layoutOrPageMod.dynamic;
            if (nextConfigOutput === "export") {
                if (!dynamic || dynamic === "auto") {
                    dynamic = "error";
                } else if (dynamic === "force-dynamic") {
                    staticGenerationStore.forceDynamic = true;
                    staticGenerationStore.dynamicShouldError = true;
                    staticGenerationBailout(`output: export`, {
                        dynamic,
                        link: "https://nextjs.org/docs/advanced-features/static-html-export"
                    });
                }
            }
            if (typeof dynamic === "string") {
                if (dynamic === "error") {
                    staticGenerationStore.dynamicShouldError = true;
                } else if (dynamic === "force-dynamic") {
                    staticGenerationStore.forceDynamic = true;
                    staticGenerationBailout(`force-dynamic`, {
                        dynamic
                    });
                } else {
                    staticGenerationStore.dynamicShouldError = false;
                    if (dynamic === "force-static") {
                        staticGenerationStore.forceStatic = true;
                    } else {
                        staticGenerationStore.forceStatic = false;
                    }
                }
            }
            if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache) === "string") {
                staticGenerationStore.fetchCache = layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache;
            }
            if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) === "number") {
                defaultRevalidate = layoutOrPageMod.revalidate;
                if (typeof staticGenerationStore.revalidate === "undefined" || typeof staticGenerationStore.revalidate === "number" && staticGenerationStore.revalidate > defaultRevalidate) {
                    staticGenerationStore.revalidate = defaultRevalidate;
                }
                if (staticGenerationStore.isStaticGeneration && defaultRevalidate === 0) {
                    const { DynamicServerError } = ComponentMod.serverHooks;
                    const dynamicUsageDescription = `revalidate: 0 configured ${segment}`;
                    staticGenerationStore.dynamicUsageDescription = dynamicUsageDescription;
                    throw new DynamicServerError(dynamicUsageDescription);
                }
            }
            if (staticGenerationStore == null ? void 0 : staticGenerationStore.dynamicUsageErr) {
                throw staticGenerationStore.dynamicUsageErr;
            }
            let Component = layoutOrPageMod ? (0, _interopdefault.interopDefault)(layoutOrPageMod) : undefined;
            if (dev) {
                const { isValidElementType } = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-is/index.js (ecmascript, rsc)");
                if ((isPage || typeof Component !== "undefined") && !isValidElementType(Component)) {
                    throw new Error(`The default export is not a React Component in page: "${pagePath}"`);
                }
                if (typeof ErrorComponent !== "undefined" && !isValidElementType(ErrorComponent)) {
                    throw new Error(`The default export of error is not a React Component in page: ${segment}`);
                }
                if (typeof Loading !== "undefined" && !isValidElementType(Loading)) {
                    throw new Error(`The default export of loading is not a React Component in ${segment}`);
                }
                if (typeof NotFound !== "undefined" && !isValidElementType(NotFound)) {
                    throw new Error(`The default export of notFound is not a React Component in ${segment}`);
                }
            }
            const segmentParam = getDynamicParamFromSegment(segment);
            const currentParams = segmentParam && segmentParam.value !== null ? {
                ...parentParams,
                [segmentParam.param]: segmentParam.value
            } : parentParams;
            const actualSegment = segmentParam ? segmentParam.treeSegment : segment;
            const parallelRouteMap = await Promise.all(Object.keys(parallelRoutes).map(async (parallelRouteKey)=>{
                const currentSegmentPath = firstItem ? [
                    parallelRouteKey
                ] : [
                    actualSegment,
                    parallelRouteKey
                ];
                const parallelRoute = parallelRoutes[parallelRouteKey];
                const childSegment = parallelRoute[0];
                const childSegmentParam = getDynamicParamFromSegment(childSegment);
                if (isPrefetch && (Loading || !hasLoadingComponentInTree(parallelRoute))) {
                    const childProp = {
                        current: null,
                        segment: (0, _createflightrouterstatefromloadertree.addSearchParamsIfPageSegment)(childSegmentParam ? childSegmentParam.treeSegment : childSegment, query)
                    };
                    return [
                        parallelRouteKey,
                        _react.default.createElement(LayoutRouter, {
                            parallelRouterKey: parallelRouteKey,
                            segmentPath: createSegmentPath(currentSegmentPath),
                            loading: Loading ? _react.default.createElement(Loading, null) : undefined,
                            loadingStyles: loadingStyles,
                            hasLoading: Boolean(Loading),
                            error: ErrorComponent,
                            errorStyles: errorStyles,
                            template: _react.default.createElement(Template, null, _react.default.createElement(RenderFromTemplateContext, null)),
                            templateStyles: templateStyles,
                            notFound: NotFound ? _react.default.createElement(NotFound, null) : undefined,
                            notFoundStyles: notFoundStyles,
                            childProp: childProp
                        })
                    ];
                }
                const { Component: ChildComponent, styles: childStyles } = await createComponentTree({
                    createSegmentPath: (child)=>{
                        return createSegmentPath([
                            ...currentSegmentPath,
                            ...child
                        ]);
                    },
                    loaderTree: parallelRoute,
                    parentParams: currentParams,
                    rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,
                    injectedCSS: injectedCSSWithCurrentLayout,
                    injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,
                    asNotFound
                });
                const childProp = {
                    current: _react.default.createElement(ChildComponent, null),
                    segment: (0, _createflightrouterstatefromloadertree.addSearchParamsIfPageSegment)(childSegmentParam ? childSegmentParam.treeSegment : childSegment, query)
                };
                const segmentPath = createSegmentPath(currentSegmentPath);
                return [
                    parallelRouteKey,
                    _react.default.createElement(LayoutRouter, {
                        parallelRouterKey: parallelRouteKey,
                        segmentPath: segmentPath,
                        error: ErrorComponent,
                        errorStyles: errorStyles,
                        loading: Loading ? _react.default.createElement(Loading, null) : undefined,
                        loadingStyles: loadingStyles,
                        hasLoading: Boolean(Loading),
                        template: _react.default.createElement(Template, null, _react.default.createElement(RenderFromTemplateContext, null)),
                        templateStyles: templateStyles,
                        notFound: NotFound ? _react.default.createElement(NotFound, null) : undefined,
                        notFoundStyles: notFoundStyles,
                        childProp: childProp,
                        styles: childStyles
                    })
                ];
            }));
            const parallelRouteComponents = parallelRouteMap.reduce((list, [parallelRouteKey, Comp])=>{
                list[parallelRouteKey] = Comp;
                return list;
            }, {});
            if (!Component) {
                return {
                    Component: ()=>_react.default.createElement(_react.default.Fragment, null, parallelRouteComponents.children),
                    styles
                };
            }
            const isClientComponent = (0, _clientreference.isClientReference)(layoutOrPageMod);
            let isLeaf = process.env.NODE_ENV === "production" ? !segment && !rootLayoutIncluded : !parallelRouteMap.length && segment === "__DEFAULT__";
            let notFoundComponent = {};
            if (NotFound && (asNotFound === "force" || asNotFound && isLeaf)) {
                notFoundComponent = {
                    children: _react.default.createElement(_react.default.Fragment, null, _react.default.createElement("meta", {
                        name: "robots",
                        content: "noindex"
                    }), process.env.NODE_ENV === "development" && _react.default.createElement("meta", {
                        name: "next-error",
                        content: "not-found"
                    }), notFoundStyles, _react.default.createElement(NotFound, null))
                };
            }
            const props = {
                ...parallelRouteComponents,
                ...notFoundComponent,
                params: currentParams,
                ...(()=>{
                    if (isClientComponent && isStaticGeneration) {
                        return {};
                    }
                    if (isPage) {
                        return searchParamsProps;
                    }
                })()
            };
            if (!isClientComponent) {
                Component = await Promise.resolve().then(()=>(0, _preloadcomponent.preloadComponent)(Component, props));
            }
            return {
                Component: ()=>{
                    return _react.default.createElement(_react.default.Fragment, null, isPage && isClientComponent && isStaticGeneration ? _react.default.createElement(StaticGenerationSearchParamsBailoutProvider, {
                        propsForComponent: props,
                        Component: Component
                    }) : _react.default.createElement(Component, props), null);
                },
                styles
            };
        };
        const generateFlight = async (options)=>{
            const walkTreeWithFlightRouterState = async ({ createSegmentPath, loaderTreeToFilter, parentParams, isFirst, flightRouterState, parentRendered, rscPayloadHead, injectedCSS, injectedFontPreloadTags, rootLayoutIncluded, asNotFound })=>{
                const [segment, parallelRoutes, components] = loaderTreeToFilter;
                const parallelRoutesKeys = Object.keys(parallelRoutes);
                const { layout } = components;
                const isLayout = typeof layout !== "undefined";
                const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
                const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
                const segmentParam = getDynamicParamFromSegment(segment);
                const currentParams = segmentParam && segmentParam.value !== null ? {
                    ...parentParams,
                    [segmentParam.param]: segmentParam.value
                } : parentParams;
                const actualSegment = (0, _createflightrouterstatefromloadertree.addSearchParamsIfPageSegment)(segmentParam ? segmentParam.treeSegment : segment, query);
                const renderComponentsOnThisLevel = !flightRouterState || !(0, _matchsegments.matchSegment)(actualSegment, flightRouterState[0]) || parallelRoutesKeys.length === 0 || flightRouterState[3] === "refetch";
                if (!parentRendered && renderComponentsOnThisLevel) {
                    const overriddenSegment = flightRouterState && (0, _matchsegments.canSegmentBeOverridden)(actualSegment, flightRouterState[0]) ? flightRouterState[0] : null;
                    return [
                        [
                            overriddenSegment ?? actualSegment,
                            (0, _createflightrouterstatefromloadertree.createFlightRouterStateFromLoaderTree)(loaderTreeToFilter, getDynamicParamFromSegment, query),
                            isPrefetch && !Boolean(components.loading) ? null : _react.default.createElement(async ()=>{
                                const { Component } = await createComponentTree({
                                    createSegmentPath,
                                    loaderTree: loaderTreeToFilter,
                                    parentParams: currentParams,
                                    firstItem: isFirst,
                                    injectedCSS,
                                    injectedFontPreloadTags,
                                    rootLayoutIncluded,
                                    asNotFound
                                });
                                return _react.default.createElement(Component, null);
                            }),
                            isPrefetch && !Boolean(components.loading) ? null : (()=>{
                                const { layoutOrPagePath } = parseLoaderTree(loaderTreeToFilter);
                                const styles = getLayerAssets({
                                    layoutOrPagePath,
                                    injectedCSS: new Set(injectedCSS),
                                    injectedFontPreloadTags: new Set(injectedFontPreloadTags)
                                });
                                return _react.default.createElement(_react.default.Fragment, null, styles, rscPayloadHead);
                            })()
                        ]
                    ];
                }
                const layoutPath = layout == null ? void 0 : layout[1];
                const injectedCSSWithCurrentLayout = new Set(injectedCSS);
                const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);
                if (layoutPath) {
                    (0, _getcssinlinedlinktags.getCssInlinedLinkTags)(clientReferenceManifest, layoutPath, injectedCSSWithCurrentLayout, true);
                    (0, _getpreloadablefonts.getPreloadableFonts)(nextFontManifest, layoutPath, injectedFontPreloadTagsWithCurrentLayout);
                }
                const paths = (await Promise.all(parallelRoutesKeys.map(async (parallelRouteKey)=>{
                    const parallelRoute = parallelRoutes[parallelRouteKey];
                    const currentSegmentPath = isFirst ? [
                        parallelRouteKey
                    ] : [
                        actualSegment,
                        parallelRouteKey
                    ];
                    const path = await walkTreeWithFlightRouterState({
                        createSegmentPath: (child)=>{
                            return createSegmentPath([
                                ...currentSegmentPath,
                                ...child
                            ]);
                        },
                        loaderTreeToFilter: parallelRoute,
                        parentParams: currentParams,
                        flightRouterState: flightRouterState && flightRouterState[1][parallelRouteKey],
                        parentRendered: parentRendered || renderComponentsOnThisLevel,
                        isFirst: false,
                        rscPayloadHead,
                        injectedCSS: injectedCSSWithCurrentLayout,
                        injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,
                        rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,
                        asNotFound
                    });
                    return path.map((item)=>{
                        if (item[0] === "__DEFAULT__" && flightRouterState && !!flightRouterState[1][parallelRouteKey][0] && flightRouterState[1][parallelRouteKey][3] !== "refetch") {
                            return null;
                        }
                        return [
                            actualSegment,
                            parallelRouteKey,
                            ...item
                        ];
                    }).filter(Boolean);
                }))).flat();
                return paths;
            };
            const flightData = (options == null ? void 0 : options.skipFlight) ? null : (await walkTreeWithFlightRouterState({
                createSegmentPath: (child)=>child,
                loaderTreeToFilter: loaderTree,
                parentParams: {},
                flightRouterState: providedFlightRouterState,
                isFirst: true,
                rscPayloadHead: _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_metadata.MetadataTree, {
                    key: requestId,
                    tree: loaderTree,
                    pathname: pathname,
                    searchParams: providedSearchParams,
                    getDynamicParamFromSegment: getDynamicParamFromSegment,
                    appUsingSizeAdjust: appUsingSizeAdjust
                })),
                injectedCSS: new Set(),
                injectedFontPreloadTags: new Set(),
                rootLayoutIncluded: false,
                asNotFound: pagePath === "/404" || (options == null ? void 0 : options.asNotFound)
            })).map((path)=>path.slice(1));
            const buildIdFlightDataPair = [
                renderOpts.buildId,
                flightData
            ];
            const readable = ComponentMod.renderToReadableStream(options ? [
                options.actionResult,
                buildIdFlightDataPair
            ] : buildIdFlightDataPair, clientReferenceManifest.clientModules, {
                context: serverContexts,
                onError: flightDataRendererErrorHandler
            }).pipeThrough((0, _nodewebstreamshelper.createBufferedTransformStream)());
            return new _flightrenderresult.FlightRenderResult(readable);
        };
        if (isFlight && !staticGenerationStore.isStaticGeneration) {
            return generateFlight();
        }
        const AppRouter = ComponentMod.AppRouter;
        const GlobalError = ComponentMod.GlobalError;
        const serverComponentsInlinedTransformStream = new TransformStream();
        const csp = req.headers["content-security-policy"];
        let nonce;
        if (csp && typeof csp === "string") {
            nonce = (0, _getscriptnoncefromheader.getScriptNonceFromHeader)(csp);
        }
        const serverComponentsRenderOpts = {
            transformStream: serverComponentsInlinedTransformStream,
            clientReferenceManifest,
            serverContexts,
            rscChunks: []
        };
        const validateRootLayout = dev ? {
            validateRootLayout: {
                assetPrefix: renderOpts.assetPrefix,
                getTree: ()=>(0, _createflightrouterstatefromloadertree.createFlightRouterStateFromLoaderTree)(loaderTree, getDynamicParamFromSegment, query)
            }
        } : {};
        async function getNotFound(tree, injectedCSS, requestPathname) {
            const depth = requestPathname.split("/").length - 2;
            const notFound = findMatchedComponent(tree, "not-found", depth);
            const [NotFound, notFoundStyles] = notFound ? await createComponentAndStyles({
                filePath: notFound[1],
                getComponent: notFound[0],
                injectedCSS
            }) : [];
            return [
                NotFound,
                notFoundStyles
            ];
        }
        async function getRootLayout(tree, injectedCSS, injectedFontPreloadTags) {
            const { layout } = tree[2];
            const layoutPath = layout == null ? void 0 : layout[1];
            const styles = getLayerAssets({
                layoutOrPagePath: layoutPath,
                injectedCSS: new Set(injectedCSS),
                injectedFontPreloadTags: new Set(injectedFontPreloadTags)
            });
            const rootLayoutModule = layout == null ? void 0 : layout[0];
            const RootLayout = rootLayoutModule ? (0, _interopdefault.interopDefault)(await rootLayoutModule()) : null;
            return [
                RootLayout,
                styles
            ];
        }
        const ServerComponentsRenderer = (0, _createservercomponentsrenderer.createServerComponentRenderer)(async (props)=>{
            const injectedCSS = new Set();
            const injectedFontPreloadTags = new Set();
            const { Component: ComponentTree, styles } = await createComponentTree({
                createSegmentPath: (child)=>child,
                loaderTree,
                parentParams: {},
                firstItem: true,
                injectedCSS,
                injectedFontPreloadTags,
                rootLayoutIncluded: false,
                asNotFound: props.asNotFound
            });
            const createMetadata = (tree, errorType)=>_react.default.createElement(_metadata.MetadataTree, {
                    key: requestId,
                    tree: tree,
                    errorType: errorType,
                    pathname: pathname,
                    searchParams: providedSearchParams,
                    getDynamicParamFromSegment: getDynamicParamFromSegment,
                    appUsingSizeAdjust: appUsingSizeAdjust
                });
            const initialTree = (0, _createflightrouterstatefromloadertree.createFlightRouterStateFromLoaderTree)(loaderTree, getDynamicParamFromSegment, query);
            return _react.default.createElement(_react.default.Fragment, null, styles, _react.default.createElement(AppRouter, {
                buildId: renderOpts.buildId,
                assetPrefix: assetPrefix,
                initialCanonicalUrl: pathname,
                initialTree: initialTree,
                initialHead: createMetadata(loaderTree, props.asNotFound ? "not-found" : undefined),
                globalErrorComponent: GlobalError
            }, _react.default.createElement(ComponentTree, null)));
        }, ComponentMod, serverComponentsRenderOpts, serverComponentsErrorHandler, nonce);
        const { HeadManagerContext } = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/head-manager-context.js (ecmascript, rsc)");
        const serverInsertedHTMLCallbacks = new Set();
        function InsertedHTML({ children }) {
            const addInsertedHtml = _react.default.useCallback((handler)=>{
                serverInsertedHTMLCallbacks.add(handler);
            }, []);
            return _react.default.createElement(HeadManagerContext.Provider, {
                value: {
                    appDir: true,
                    nonce
                }
            }, _react.default.createElement(_serverinsertedhtml.ServerInsertedHTMLContext.Provider, {
                value: addInsertedHtml
            }, children));
        }
        (_getTracer_getRootSpanAttributes = (0, _tracer.getTracer)().getRootSpanAttributes()) == null ? void 0 : _getTracer_getRootSpanAttributes.set("next.route", pagePath);
        const bodyResult = (0, _tracer.getTracer)().wrap(_constants.AppRenderSpan.getBodyResult, {
            spanName: `render route (app) ${pagePath}`,
            attributes: {
                "next.route": pagePath
            }
        }, async ({ asNotFound })=>{
            const polyfills = buildManifest.polyfillFiles.filter((polyfill)=>polyfill.endsWith(".js") && !polyfill.endsWith(".module.js")).map((polyfill)=>{
                return {
                    src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(false)}`,
                    integrity: subresourceIntegrityManifest == null ? void 0 : subresourceIntegrityManifest[polyfill]
                };
            });
            const content = _react.default.createElement(InsertedHTML, null, _react.default.createElement(ServerComponentsRenderer, {
                asNotFound: asNotFound
            }));
            let polyfillsFlushed = false;
            let flushedErrorMetaTagsUntilIndex = 0;
            const getServerInsertedHTML = (serverCapturedErrors)=>{
                const errorMetaTags = [];
                for(; flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length; flushedErrorMetaTagsUntilIndex++){
                    const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex];
                    if ((0, _notfound.isNotFoundError)(error)) {
                        errorMetaTags.push(_react.default.createElement("meta", {
                            name: "robots",
                            content: "noindex",
                            key: error.digest
                        }), process.env.NODE_ENV === "development" ? _react.default.createElement("meta", {
                            name: "next-error",
                            content: "not-found",
                            key: "next-error"
                        }) : null);
                    } else if ((0, _redirect.isRedirectError)(error)) {
                        const redirectUrl = (0, _redirect.getURLFromRedirectError)(error);
                        if (redirectUrl) {
                            errorMetaTags.push(_react.default.createElement("meta", {
                                httpEquiv: "refresh",
                                content: `0;url=${redirectUrl}`,
                                key: error.digest
                            }));
                        }
                    }
                }
                const flushed = (0, _rendertostring.renderToString)({
                    ReactDOMServer: __turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/server.edge.js (ecmascript, rsc)"),
                    element: _react.default.createElement(_react.default.Fragment, null, Array.from(serverInsertedHTMLCallbacks).map((callback, index)=>_react.default.createElement(_react.default.Fragment, {
                            key: "_next_insert" + index
                        }, callback())), polyfillsFlushed ? null : polyfills == null ? void 0 : polyfills.map((polyfill)=>{
                        return _react.default.createElement("script", {
                            key: polyfill.src,
                            src: polyfill.src,
                            integrity: polyfill.integrity,
                            noModule: true,
                            nonce: nonce
                        });
                    }), errorMetaTags)
                });
                polyfillsFlushed = true;
                return flushed;
            };
            try {
                const renderStream = await (0, _nodewebstreamshelper.renderToInitialStream)({
                    ReactDOMServer: __turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/server.edge.js (ecmascript, rsc)"),
                    element: content,
                    streamOptions: {
                        onError: htmlRendererErrorHandler,
                        nonce,
                        bootstrapScripts: [
                            ...subresourceIntegrityManifest ? buildManifest.rootMainFiles.map((src)=>({
                                    src: `${assetPrefix}/_next/` + src + getAssetQueryString(false),
                                    integrity: subresourceIntegrityManifest[src]
                                })) : buildManifest.rootMainFiles.map((src)=>`${assetPrefix}/_next/` + src + getAssetQueryString(false))
                        ]
                    }
                });
                const result = await (0, _nodewebstreamshelper.continueFromInitialStream)(renderStream, {
                    dataStream: serverComponentsRenderOpts.transformStream.readable,
                    generateStaticHTML: staticGenerationStore.isStaticGeneration || generateStaticHTML,
                    getServerInsertedHTML: ()=>getServerInsertedHTML(allCapturedErrors),
                    serverInsertedHTMLToHead: true,
                    ...validateRootLayout
                });
                return result;
            } catch (err) {
                var _err_message;
                if (err.code === "NEXT_STATIC_GEN_BAILOUT" || ((_err_message = err.message) == null ? void 0 : _err_message.includes("https://nextjs.org/docs/advanced-features/static-html-export"))) {
                    throw err;
                }
                if (err.digest === _nossrerror.NEXT_DYNAMIC_NO_SSR_CODE) {
                    (0, _log.warn)(`Entire page ${pagePath} deopted into client-side rendering. https://nextjs.org/docs/messages/deopted-into-client-rendering`, pagePath);
                }
                if ((0, _notfound.isNotFoundError)(err)) {
                    res.statusCode = 404;
                }
                let hasRedirectError = false;
                if ((0, _redirect.isRedirectError)(err)) {
                    hasRedirectError = true;
                    res.statusCode = 307;
                    if (err.mutableCookies) {
                        const headers = new Headers();
                        if ((0, _requestcookies.appendMutableCookies)(headers, err.mutableCookies)) {
                            res.setHeader("set-cookie", Array.from(headers.values()));
                        }
                    }
                    res.setHeader("Location", (0, _redirect.getURLFromRedirectError)(err));
                }
                const is404 = res.statusCode === 404;
                const injectedCSS = new Set();
                const injectedFontPreloadTags = new Set();
                const [RootLayout, rootStyles] = await getRootLayout(loaderTree, injectedCSS, injectedFontPreloadTags);
                const [NotFound, notFoundStyles] = await getNotFound(loaderTree, injectedCSS, pathname);
                const serverErrorComponentsRenderOpts = {
                    ...serverComponentsRenderOpts,
                    rscChunks: [],
                    transformStream: is404 ? new TransformStream() : (0, _nodewebstreamshelper.cloneTransformStream)(serverComponentsRenderOpts.transformStream)
                };
                const errorType = is404 ? "not-found" : hasRedirectError ? "redirect" : undefined;
                const errorMeta = _react.default.createElement(_react.default.Fragment, null, res.statusCode >= 400 && _react.default.createElement("meta", {
                    name: "robots",
                    content: "noindex"
                }), process.env.NODE_ENV === "development" && _react.default.createElement("meta", {
                    name: "next-error",
                    content: "not-found"
                }));
                const ErrorPage = (0, _createservercomponentsrenderer.createServerComponentRenderer)(async ()=>{
                    const head = _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_metadata.MetadataTree, {
                        key: requestId,
                        tree: loaderTree,
                        pathname: pathname,
                        errorType: errorType,
                        searchParams: providedSearchParams,
                        getDynamicParamFromSegment: getDynamicParamFromSegment,
                        appUsingSizeAdjust: appUsingSizeAdjust
                    }), errorMeta);
                    const notFoundLoaderTree = is404 ? [
                        "__DEFAULT__",
                        {},
                        loaderTree[2]
                    ] : loaderTree;
                    const initialTree = (0, _createflightrouterstatefromloadertree.createFlightRouterStateFromLoaderTree)(notFoundLoaderTree, getDynamicParamFromSegment, query);
                    const GlobalNotFound = NotFound || _error.NotFound;
                    const ErrorLayout = RootLayout || ErrorHtml;
                    const notFoundElement = _react.default.createElement(ErrorLayout, {
                        params: {}
                    }, rootStyles, notFoundStyles, _react.default.createElement(GlobalNotFound, null));
                    return _react.default.createElement(AppRouter, {
                        buildId: renderOpts.buildId,
                        assetPrefix: assetPrefix,
                        initialCanonicalUrl: pathname,
                        initialTree: initialTree,
                        initialHead: head,
                        globalErrorComponent: GlobalError
                    }, is404 ? notFoundElement : _react.default.createElement(ErrorHtml, {
                        head: head
                    }));
                }, ComponentMod, serverErrorComponentsRenderOpts, serverComponentsErrorHandler, nonce);
                try {
                    const renderStream = await (0, _nodewebstreamshelper.renderToInitialStream)({
                        ReactDOMServer: __turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/server.edge.js (ecmascript, rsc)"),
                        element: _react.default.createElement(ErrorPage, null),
                        streamOptions: {
                            nonce,
                            bootstrapScripts: subresourceIntegrityManifest ? buildManifest.rootMainFiles.map((src)=>({
                                    src: `${assetPrefix}/_next/` + src + getAssetQueryString(false),
                                    integrity: subresourceIntegrityManifest[src]
                                })) : buildManifest.rootMainFiles.map((src)=>`${assetPrefix}/_next/` + src + getAssetQueryString(false))
                        }
                    });
                    return await (0, _nodewebstreamshelper.continueFromInitialStream)(renderStream, {
                        dataStream: serverErrorComponentsRenderOpts.transformStream.readable,
                        generateStaticHTML: staticGenerationStore.isStaticGeneration,
                        getServerInsertedHTML: ()=>getServerInsertedHTML([]),
                        serverInsertedHTMLToHead: true,
                        ...validateRootLayout
                    });
                } catch (finalErr) {
                    if (process.env.NODE_ENV !== "production" && (0, _notfound.isNotFoundError)(finalErr)) {
                        const bailOnNotFound = __turbopack_require__("[project]/node_modules/next/dist/client/components/dev-root-not-found-boundary.js (ecmascript, rsc)").bailOnNotFound;
                        bailOnNotFound();
                    }
                    throw finalErr;
                }
            }
        });
        const actionRequestResult = await (0, _actionhandler.handleAction)({
            req,
            res,
            ComponentMod,
            pathname: renderOpts.pathname,
            serverActionsManifest,
            generateFlight,
            staticGenerationStore,
            requestStore,
            serverActionsBodySizeLimit
        });
        if (actionRequestResult === "not-found") {
            return new _renderresult.default(await bodyResult({
                asNotFound: "force"
            }));
        } else if (actionRequestResult) {
            return actionRequestResult;
        }
        const renderResult = new _renderresult.default(await bodyResult({
            asNotFound: pagePath === "/404"
        }));
        if (staticGenerationStore.pendingRevalidates) {
            await Promise.all(staticGenerationStore.pendingRevalidates);
        }
        (0, _patchfetch.addImplicitTags)(staticGenerationStore);
        renderOpts.fetchTags = (_staticGenerationStore_tags = staticGenerationStore.tags) == null ? void 0 : _staticGenerationStore_tags.join(",");
        if (staticGenerationStore.isStaticGeneration) {
            const htmlResult = await (0, _nodewebstreamshelper.streamToBufferedResult)(renderResult);
            if (capturedErrors.length > 0) {
                throw capturedErrors[0];
            }
            const filteredFlightData = await (0, _nodewebstreamshelper.streamToBufferedResult)(await generateFlight());
            if (staticGenerationStore.forceStatic === false) {
                staticGenerationStore.revalidate = 0;
            }
            const extraRenderResultMeta = {
                pageData: filteredFlightData,
                revalidate: staticGenerationStore.revalidate ?? defaultRevalidate
            };
            if (extraRenderResultMeta.revalidate === 0) {
                extraRenderResultMeta.staticBailoutInfo = {
                    description: staticGenerationStore.dynamicUsageDescription,
                    stack: staticGenerationStore.dynamicUsageStack
                };
            }
            return new _renderresult.default(htmlResult, {
                ...extraRenderResultMeta
            });
        }
        return renderResult;
    };
    return _requestasyncstoragewrapper.RequestAsyncStorageWrapper.wrap(requestAsyncStorage, {
        req,
        res,
        renderOpts
    }, ()=>_staticgenerationasyncstoragewrapper.StaticGenerationAsyncStorageWrapper.wrap(staticGenerationAsyncStorage, {
            pathname: pagePath,
            renderOpts
        }, ()=>wrappedRender()));
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        var ReactVersion = '18.3.0-canary-9377e1010-20230712';
        var Internals = {
            usingClientEntryPoint: false,
            Events: null,
            Dispatcher: {
                current: null
            }
        };
        var Dispatcher = Internals.Dispatcher;
        function prefetchDNS(href) {
            var passedOptionArg;
            {
                if (arguments[1] !== undefined) {
                    passedOptionArg = arguments[1];
                }
            }
            var dispatcher = Dispatcher.current;
            if (dispatcher) {
                {
                    if (passedOptionArg !== undefined) {
                        dispatcher.prefetchDNS(href, passedOptionArg);
                    } else {
                        dispatcher.prefetchDNS(href);
                    }
                }
            }
        }
        function preconnect(href, options) {
            var dispatcher = Dispatcher.current;
            if (dispatcher) {
                dispatcher.preconnect(href, options);
            }
        }
        function preload(href, options) {
            var dispatcher = Dispatcher.current;
            if (dispatcher) {
                dispatcher.preload(href, options);
            }
        }
        function preinit(href, options) {
            var dispatcher = Dispatcher.current;
            if (dispatcher) {
                dispatcher.preinit(href, options);
            }
        }
        function useFormStatus() {
            {
                throw new Error('Not implemented.');
            }
        }
        function createPortal() {
            throw new Error('createPortal was called on the server. Portals are not currently' + ' supported on the server. Update your program to conditionally call' + ' createPortal on the client only.');
        }
        function flushSync() {
            throw new Error('flushSync was called on the server. This is likely caused by a' + ' function being called during render or in module scope that was' + ' intended to be called from an effect or event handler. Update your' + ' to not call flushSync no the server.');
        }
        function batchedUpdates(fn, a) {
            return fn(a);
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal;
        exports.experimental_useFormStatus = useFormStatus;
        exports.flushSync = flushSync;
        exports.preconnect = preconnect;
        exports.prefetchDNS = prefetchDNS;
        exports.preinit = preinit;
        exports.preload = preload;
        exports.unstable_batchedUpdates = batchedUpdates;
        exports.version = ReactVersion;
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-dom/server-rendering-stub.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/cjs/react-dom-server-rendering-stub.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, rsc)");
        var ReactDOM = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/server-rendering-stub.js (ecmascript, rsc)");
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
            {
                {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                }
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                });
                argsWithFormat.unshift('Warning: ' + format);
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        function scheduleWork(callback) {
            setTimeout(callback, 0);
        }
        var VIEW_SIZE = 512;
        var currentView = null;
        var writtenBytes = 0;
        function beginWriting(destination) {
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
        }
        function writeChunk(destination, chunk) {
            if (chunk.byteLength === 0) {
                return;
            }
            if (chunk.byteLength > VIEW_SIZE) {
                {
                    if (precomputedChunkSet.has(chunk)) {
                        error('A large precomputed chunk was passed to writeChunk without being copied.' + ' Large chunks get enqueued directly and are not copied. This is incompatible with precomputed chunks because you cannot enqueue the same precomputed chunk twice.' + ' Use "cloneChunk" to make a copy of this large precomputed chunk before writing it. This is a bug in React.');
                    }
                }
                if (writtenBytes > 0) {
                    destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                    currentView = new Uint8Array(VIEW_SIZE);
                    writtenBytes = 0;
                }
                destination.enqueue(chunk);
                return;
            }
            var bytesToWrite = chunk;
            var allowableBytes = currentView.length - writtenBytes;
            if (allowableBytes < bytesToWrite.byteLength) {
                if (allowableBytes === 0) {
                    destination.enqueue(currentView);
                } else {
                    currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
                    destination.enqueue(currentView);
                    bytesToWrite = bytesToWrite.subarray(allowableBytes);
                }
                currentView = new Uint8Array(VIEW_SIZE);
                writtenBytes = 0;
            }
            currentView.set(bytesToWrite, writtenBytes);
            writtenBytes += bytesToWrite.byteLength;
        }
        function writeChunkAndReturn(destination, chunk) {
            writeChunk(destination, chunk);
            return true;
        }
        function completeWriting(destination) {
            if (currentView && writtenBytes > 0) {
                destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                currentView = null;
                writtenBytes = 0;
            }
        }
        function close$1(destination) {
            destination.close();
        }
        var textEncoder = new TextEncoder();
        function stringToChunk(content) {
            return textEncoder.encode(content);
        }
        var precomputedChunkSet = new Set();
        function byteLengthOfChunk(chunk) {
            return chunk.byteLength;
        }
        function closeWithError(destination, error) {
            if (typeof destination.error === 'function') {
                destination.error(error);
            } else {
                destination.close();
            }
        }
        var CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference');
        var SERVER_REFERENCE_TAG = Symbol.for('react.server.reference');
        function isClientReference(reference) {
            return reference.$$typeof === CLIENT_REFERENCE_TAG;
        }
        function isServerReference(reference) {
            return reference.$$typeof === SERVER_REFERENCE_TAG;
        }
        function registerClientReference(proxyImplementation, id, exportName) {
            return registerClientReferenceImpl(proxyImplementation, id + '#' + exportName, false);
        }
        function registerClientReferenceImpl(proxyImplementation, id, async) {
            return Object.defineProperties(proxyImplementation, {
                $$typeof: {
                    value: CLIENT_REFERENCE_TAG
                },
                $$id: {
                    value: id
                },
                $$async: {
                    value: async
                }
            });
        }
        var FunctionBind = Function.prototype.bind;
        var ArraySlice = Array.prototype.slice;
        function bind() {
            var newFn = FunctionBind.apply(this, arguments);
            if (this.$$typeof === SERVER_REFERENCE_TAG) {
                var args = ArraySlice.call(arguments, 1);
                newFn.$$typeof = SERVER_REFERENCE_TAG;
                newFn.$$id = this.$$id;
                newFn.$$bound = this.$$bound ? this.$$bound.concat(args) : args;
            }
            return newFn;
        }
        function registerServerReference(reference, id, exportName) {
            return Object.defineProperties(reference, {
                $$typeof: {
                    value: SERVER_REFERENCE_TAG
                },
                $$id: {
                    value: exportName === null ? id : id + '#' + exportName
                },
                $$bound: {
                    value: null
                },
                bind: {
                    value: bind
                }
            });
        }
        var PROMISE_PROTOTYPE = Promise.prototype;
        var deepProxyHandlers = {
            get: function(target, name, receiver) {
                switch(name){
                    case '$$typeof':
                        return target.$$typeof;
                    case '$$id':
                        return target.$$id;
                    case '$$async':
                        return target.$$async;
                    case 'name':
                        return target.name;
                    case 'displayName':
                        return undefined;
                    case 'defaultProps':
                        return undefined;
                    case 'toJSON':
                        return undefined;
                    case Symbol.toPrimitive:
                        return Object.prototype[Symbol.toPrimitive];
                    case 'Provider':
                        throw new Error("Cannot render a Client Context Provider on the Server. " + "Instead, you can export a Client Component wrapper " + "that itself renders a Client Context Provider.");
                }
                var expression = String(target.name) + '.' + String(name);
                throw new Error("Cannot access " + expression + " on the server. " + 'You cannot dot into a client module from a server component. ' + 'You can only pass the imported name through.');
            },
            set: function() {
                throw new Error('Cannot assign to a client module from a server module.');
            }
        };
        var proxyHandlers = {
            get: function(target, name, receiver) {
                switch(name){
                    case '$$typeof':
                        return target.$$typeof;
                    case '$$id':
                        return target.$$id;
                    case '$$async':
                        return target.$$async;
                    case 'name':
                        return target.name;
                    case 'defaultProps':
                        return undefined;
                    case 'toJSON':
                        return undefined;
                    case Symbol.toPrimitive:
                        return Object.prototype[Symbol.toPrimitive];
                    case '__esModule':
                        var moduleId = target.$$id;
                        target.default = registerClientReferenceImpl(function() {
                            throw new Error("Attempted to call the default export of " + moduleId + " from the server " + "but it's on the client. It's not possible to invoke a client function from " + "the server, it can only be rendered as a Component or passed to props of a " + "Client Component.");
                        }, target.$$id + '#', target.$$async);
                        return true;
                    case 'then':
                        if (target.then) {
                            return target.then;
                        }
                        if (!target.$$async) {
                            var clientReference = registerClientReferenceImpl({}, target.$$id, true);
                            var proxy = new Proxy(clientReference, proxyHandlers);
                            target.status = 'fulfilled';
                            target.value = proxy;
                            var then = target.then = registerClientReferenceImpl(function then(resolve, reject) {
                                return Promise.resolve(resolve(proxy));
                            }, target.$$id + '#then', false);
                            return then;
                        } else {
                            return undefined;
                        }
                }
                var cachedReference = target[name];
                if (!cachedReference) {
                    var reference = registerClientReferenceImpl(function() {
                        throw new Error("Attempted to call " + String(name) + "() from the server but " + String(name) + " is on the client. " + "It's not possible to invoke a client function from the server, it can " + "only be rendered as a Component or passed to props of a Client Component.");
                    }, target.$$id + '#' + name, target.$$async);
                    Object.defineProperty(reference, 'name', {
                        value: name
                    });
                    cachedReference = target[name] = new Proxy(reference, deepProxyHandlers);
                }
                return cachedReference;
            },
            getPrototypeOf: function(target) {
                return PROMISE_PROTOTYPE;
            },
            set: function() {
                throw new Error('Cannot assign to a client module from a server module.');
            }
        };
        function createClientModuleProxy(moduleId) {
            var clientReference = registerClientReferenceImpl({}, moduleId, false);
            return new Proxy(clientReference, proxyHandlers);
        }
        function getClientReferenceKey(reference) {
            return reference.$$async ? reference.$$id + '#async' : reference.$$id;
        }
        function resolveClientReferenceMetadata(config, clientReference) {
            var modulePath = clientReference.$$id;
            var name = '';
            var resolvedModuleData = config[modulePath];
            if (resolvedModuleData) {
                name = resolvedModuleData.name;
            } else {
                var idx = modulePath.lastIndexOf('#');
                if (idx !== -1) {
                    name = modulePath.slice(idx + 1);
                    resolvedModuleData = config[modulePath.slice(0, idx)];
                }
                if (!resolvedModuleData) {
                    throw new Error('Could not find the module "' + modulePath + '" in the React Client Manifest. ' + 'This is probably a bug in the React Server Components bundler.');
                }
            }
            return {
                id: resolvedModuleData.id,
                chunks: resolvedModuleData.chunks,
                name: name,
                async: !!clientReference.$$async
            };
        }
        function getServerReferenceId(config, serverReference) {
            return serverReference.$$id;
        }
        function getServerReferenceBoundArguments(config, serverReference) {
            return serverReference.$$bound;
        }
        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var ReactDOMFlightServerDispatcher = {
            prefetchDNS: prefetchDNS,
            preconnect: preconnect,
            preload: preload,
            preinit: preinit
        };
        function prefetchDNS(href, options) {
            {
                if (typeof href === 'string') {
                    var request = resolveRequest();
                    if (request) {
                        var hints = getHints(request);
                        var key = 'D' + href;
                        if (hints.has(key)) {
                            return;
                        }
                        hints.add(key);
                        if (options) {
                            emitHint(request, 'D', [
                                href,
                                options
                            ]);
                        } else {
                            emitHint(request, 'D', href);
                        }
                    }
                }
            }
        }
        function preconnect(href, options) {
            {
                if (typeof href === 'string') {
                    var request = resolveRequest();
                    if (request) {
                        var hints = getHints(request);
                        var crossOrigin = options == null || typeof options.crossOrigin !== 'string' ? null : options.crossOrigin === 'use-credentials' ? 'use-credentials' : '';
                        var key = "C" + (crossOrigin === null ? 'null' : crossOrigin) + "|" + href;
                        if (hints.has(key)) {
                            return;
                        }
                        hints.add(key);
                        if (options) {
                            emitHint(request, 'C', [
                                href,
                                options
                            ]);
                        } else {
                            emitHint(request, 'C', href);
                        }
                    }
                }
            }
        }
        function preload(href, options) {
            {
                if (typeof href === 'string') {
                    var request = resolveRequest();
                    if (request) {
                        var hints = getHints(request);
                        var key = 'L' + href;
                        if (hints.has(key)) {
                            return;
                        }
                        hints.add(key);
                        emitHint(request, 'L', [
                            href,
                            options
                        ]);
                    }
                }
            }
        }
        function preinit(href, options) {
            {
                if (typeof href === 'string') {
                    var request = resolveRequest();
                    if (request) {
                        var hints = getHints(request);
                        var key = 'I' + href;
                        if (hints.has(key)) {
                            return;
                        }
                        hints.add(key);
                        emitHint(request, 'I', [
                            href,
                            options
                        ]);
                    }
                }
            }
        }
        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;
        function prepareHostDispatcher() {
            ReactDOMCurrentDispatcher.current = ReactDOMFlightServerDispatcher;
        }
        function createHints() {
            return new Set();
        }
        var supportsRequestStorage = typeof AsyncLocalStorage === 'function';
        var requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null;
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var rendererSigil;
        {
            rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev) {
            {
                prev.context._currentValue = prev.parentValue;
            }
        }
        function pushNode(next) {
            {
                next.context._currentValue = next.value;
            }
        }
        function popToNearestCommonAncestor(prev, next) {
            if (prev === next) ;
            else {
                popNode(prev);
                var parentPrev = prev.parent;
                var parentNext = next.parent;
                if (parentPrev === null) {
                    if (parentNext !== null) {
                        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
                    }
                } else {
                    if (parentNext === null) {
                        throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
                    }
                    popToNearestCommonAncestor(parentPrev, parentNext);
                    pushNode(next);
                }
            }
        }
        function popAllPrevious(prev) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev !== null) {
                popAllPrevious(parentPrev);
            }
        }
        function pushAllNext(next) {
            var parentNext = next.parent;
            if (parentNext !== null) {
                pushAllNext(parentNext);
            }
            pushNode(next);
        }
        function popPreviousToCommonLevel(prev, next) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev === null) {
                throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
            }
            if (parentPrev.depth === next.depth) {
                popToNearestCommonAncestor(parentPrev, next);
            } else {
                popPreviousToCommonLevel(parentPrev, next);
            }
        }
        function popNextToCommonLevel(prev, next) {
            var parentNext = next.parent;
            if (parentNext === null) {
                throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
            }
            if (prev.depth === parentNext.depth) {
                popToNearestCommonAncestor(prev, parentNext);
            } else {
                popNextToCommonLevel(prev, parentNext);
            }
            pushNode(next);
        }
        function switchContext(newSnapshot) {
            var prev = currentActiveSnapshot;
            var next = newSnapshot;
            if (prev !== next) {
                if (prev === null) {
                    pushAllNext(next);
                } else if (next === null) {
                    popAllPrevious(prev);
                } else if (prev.depth === next.depth) {
                    popToNearestCommonAncestor(prev, next);
                } else if (prev.depth > next.depth) {
                    popPreviousToCommonLevel(prev, next);
                } else {
                    popNextToCommonLevel(prev, next);
                }
                currentActiveSnapshot = next;
            }
        }
        function pushProvider(context, nextValue) {
            var prevValue;
            {
                prevValue = context._currentValue;
                context._currentValue = nextValue;
                {
                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
                    }
                    context._currentRenderer = rendererSigil;
                }
            }
            var prevNode = currentActiveSnapshot;
            var newNode = {
                parent: prevNode,
                depth: prevNode === null ? 0 : prevNode.depth + 1,
                context: context,
                parentValue: prevValue,
                value: nextValue
            };
            currentActiveSnapshot = newNode;
            return newNode;
        }
        function popProvider() {
            var prevSnapshot = currentActiveSnapshot;
            if (prevSnapshot === null) {
                throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
            }
            {
                var value = prevSnapshot.parentValue;
                if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                    prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
                } else {
                    prevSnapshot.context._currentValue = value;
                }
            }
            return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
            return currentActiveSnapshot;
        }
        function readContext$1(context) {
            var value = context._currentValue;
            return value;
        }
        var SuspenseException = new Error("Suspense Exception: This is not a real error! It's an implementation " + 'detail of `use` to interrupt the current render. You must either ' + 'rethrow it immediately, or move the `use` call outside of the ' + '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\n\n' + 'To handle async errors, wrap your component in an error boundary, or ' + "call the promise's `.catch` method and pass the result to `use`");
        function createThenableState() {
            return [];
        }
        function noop() {}
        function trackUsedThenable(thenableState, thenable, index) {
            var previous = thenableState[index];
            if (previous === undefined) {
                thenableState.push(thenable);
            } else {
                if (previous !== thenable) {
                    thenable.then(noop, noop);
                    thenable = previous;
                }
            }
            switch(thenable.status){
                case 'fulfilled':
                    {
                        var fulfilledValue = thenable.value;
                        return fulfilledValue;
                    }
                case 'rejected':
                    {
                        var rejectedError = thenable.reason;
                        throw rejectedError;
                    }
                default:
                    {
                        if (typeof thenable.status === 'string') ;
                        else {
                            var pendingThenable = thenable;
                            pendingThenable.status = 'pending';
                            pendingThenable.then(function(fulfilledValue) {
                                if (thenable.status === 'pending') {
                                    var fulfilledThenable = thenable;
                                    fulfilledThenable.status = 'fulfilled';
                                    fulfilledThenable.value = fulfilledValue;
                                }
                            }, function(error) {
                                if (thenable.status === 'pending') {
                                    var rejectedThenable = thenable;
                                    rejectedThenable.status = 'rejected';
                                    rejectedThenable.reason = error;
                                }
                            });
                            switch(thenable.status){
                                case 'fulfilled':
                                    {
                                        var fulfilledThenable = thenable;
                                        return fulfilledThenable.value;
                                    }
                                case 'rejected':
                                    {
                                        var rejectedThenable = thenable;
                                        throw rejectedThenable.reason;
                                    }
                            }
                        }
                        suspendedThenable = thenable;
                        throw SuspenseException;
                    }
            }
        }
        var suspendedThenable = null;
        function getSuspendedThenable() {
            if (suspendedThenable === null) {
                throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');
            }
            var thenable = suspendedThenable;
            suspendedThenable = null;
            return thenable;
        }
        var currentRequest$1 = null;
        var thenableIndexCounter = 0;
        var thenableState = null;
        function prepareToUseHooksForRequest(request) {
            currentRequest$1 = request;
        }
        function resetHooksForRequest() {
            currentRequest$1 = null;
        }
        function prepareToUseHooksForComponent(prevThenableState) {
            thenableIndexCounter = 0;
            thenableState = prevThenableState;
        }
        function getThenableStateAfterSuspending() {
            var state = thenableState;
            thenableState = null;
            return state;
        }
        function readContext(context) {
            {
                if (context.$$typeof !== REACT_SERVER_CONTEXT_TYPE) {
                    if (isClientReference(context)) {
                        error('Cannot read a Client Context from a Server Component.');
                    } else {
                        error('Only createServerContext is supported in Server Components.');
                    }
                }
                if (currentRequest$1 === null) {
                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                }
            }
            return readContext$1(context);
        }
        var HooksDispatcher = {
            useMemo: function(nextCreate) {
                return nextCreate();
            },
            useCallback: function(callback) {
                return callback;
            },
            useDebugValue: function() {},
            useDeferredValue: unsupportedHook,
            useTransition: unsupportedHook,
            readContext: readContext,
            useContext: readContext,
            useReducer: unsupportedHook,
            useRef: unsupportedHook,
            useState: unsupportedHook,
            useInsertionEffect: unsupportedHook,
            useLayoutEffect: unsupportedHook,
            useImperativeHandle: unsupportedHook,
            useEffect: unsupportedHook,
            useId: useId,
            useSyncExternalStore: unsupportedHook,
            useCacheRefresh: function() {
                return unsupportedRefresh;
            },
            useMemoCache: function(size) {
                var data = new Array(size);
                for(var i = 0; i < size; i++){
                    data[i] = REACT_MEMO_CACHE_SENTINEL;
                }
                return data;
            },
            use: use
        };
        function unsupportedHook() {
            throw new Error('This Hook is not supported in Server Components.');
        }
        function unsupportedRefresh() {
            throw new Error('Refreshing the cache is not supported in Server Components.');
        }
        function useId() {
            if (currentRequest$1 === null) {
                throw new Error('useId can only be used while React is rendering');
            }
            var id = currentRequest$1.identifierCount++;
            return ':' + currentRequest$1.identifierPrefix + 'S' + id.toString(32) + ':';
        }
        function use(usable) {
            if (usable !== null && typeof usable === 'object' || typeof usable === 'function') {
                if (typeof usable.then === 'function') {
                    var thenable = usable;
                    var index = thenableIndexCounter;
                    thenableIndexCounter += 1;
                    if (thenableState === null) {
                        thenableState = createThenableState();
                    }
                    return trackUsedThenable(thenableState, thenable, index);
                } else if (usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {
                    var context = usable;
                    return readContext(context);
                }
            }
            {
                if (isClientReference(usable)) {
                    error('Cannot use() an already resolved Client Reference.');
                }
            }
            throw new Error('An unsupported type was passed to use(): ' + String(usable));
        }
        function createSignal() {
            return new AbortController().signal;
        }
        function resolveCache() {
            var request = resolveRequest();
            if (request) {
                return getCache(request);
            }
            return new Map();
        }
        var DefaultCacheDispatcher = {
            getCacheSignal: function() {
                var cache = resolveCache();
                var entry = cache.get(createSignal);
                if (entry === undefined) {
                    entry = createSignal();
                    cache.set(createSignal, entry);
                }
                return entry;
            },
            getCacheForType: function(resourceType) {
                var cache = resolveCache();
                var entry = cache.get(resourceType);
                if (entry === undefined) {
                    entry = resourceType();
                    cache.set(resourceType, entry);
                }
                return entry;
            }
        };
        var isArrayImpl = Array.isArray;
        function isArray(a) {
            return isArrayImpl(a);
        }
        var jsxPropsParents = new WeakMap();
        var jsxChildrenParents = new WeakMap();
        function isObjectPrototype(object) {
            if (!object) {
                return false;
            }
            var ObjectPrototype = Object.prototype;
            if (object === ObjectPrototype) {
                return true;
            }
            if (Object.getPrototypeOf(object)) {
                return false;
            }
            var names = Object.getOwnPropertyNames(object);
            for(var i = 0; i < names.length; i++){
                if (!(names[i] in ObjectPrototype)) {
                    return false;
                }
            }
            return true;
        }
        function isSimpleObject(object) {
            if (!isObjectPrototype(Object.getPrototypeOf(object))) {
                return false;
            }
            var names = Object.getOwnPropertyNames(object);
            for(var i = 0; i < names.length; i++){
                var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
                if (!descriptor) {
                    return false;
                }
                if (!descriptor.enumerable) {
                    if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
                        continue;
                    }
                    return false;
                }
            }
            return true;
        }
        function objectName(object) {
            var name = Object.prototype.toString.call(object);
            return name.replace(/^\[object (.*)\]$/, function(m, p0) {
                return p0;
            });
        }
        function describeKeyForErrorMessage(key) {
            var encodedKey = JSON.stringify(key);
            return '"' + key + '"' === encodedKey ? key : encodedKey;
        }
        function describeValueForErrorMessage(value) {
            switch(typeof value){
                case 'string':
                    {
                        return JSON.stringify(value.length <= 10 ? value : value.slice(0, 10) + '...');
                    }
                case 'object':
                    {
                        if (isArray(value)) {
                            return '[...]';
                        }
                        var name = objectName(value);
                        if (name === 'Object') {
                            return '{...}';
                        }
                        return name;
                    }
                case 'function':
                    return 'function';
                default:
                    return String(value);
            }
        }
        function describeElementType(type) {
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
            }
            if (typeof type === 'object') {
                switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                        return describeElementType(type.render);
                    case REACT_MEMO_TYPE:
                        return describeElementType(type.type);
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return describeElementType(init(payload));
                            } catch (x) {}
                        }
                }
            }
            return '';
        }
        function describeObjectForErrorMessage(objectOrArray, expandedName) {
            var objKind = objectName(objectOrArray);
            if (objKind !== 'Object' && objKind !== 'Array') {
                return objKind;
            }
            var str = '';
            var start = -1;
            var length = 0;
            if (isArray(objectOrArray)) {
                if (jsxChildrenParents.has(objectOrArray)) {
                    var type = jsxChildrenParents.get(objectOrArray);
                    str = '<' + describeElementType(type) + '>';
                    var array = objectOrArray;
                    for(var i = 0; i < array.length; i++){
                        var value = array[i];
                        var substr = void 0;
                        if (typeof value === 'string') {
                            substr = value;
                        } else if (typeof value === 'object' && value !== null) {
                            substr = '{' + describeObjectForErrorMessage(value) + '}';
                        } else {
                            substr = '{' + describeValueForErrorMessage(value) + '}';
                        }
                        if ('' + i === expandedName) {
                            start = str.length;
                            length = substr.length;
                            str += substr;
                        } else if (substr.length < 15 && str.length + substr.length < 40) {
                            str += substr;
                        } else {
                            str += '{...}';
                        }
                    }
                    str += '</' + describeElementType(type) + '>';
                } else {
                    str = '[';
                    var _array = objectOrArray;
                    for(var _i = 0; _i < _array.length; _i++){
                        if (_i > 0) {
                            str += ', ';
                        }
                        var _value = _array[_i];
                        var _substr = void 0;
                        if (typeof _value === 'object' && _value !== null) {
                            _substr = describeObjectForErrorMessage(_value);
                        } else {
                            _substr = describeValueForErrorMessage(_value);
                        }
                        if ('' + _i === expandedName) {
                            start = str.length;
                            length = _substr.length;
                            str += _substr;
                        } else if (_substr.length < 10 && str.length + _substr.length < 40) {
                            str += _substr;
                        } else {
                            str += '...';
                        }
                    }
                    str += ']';
                }
            } else {
                if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {
                    str = '<' + describeElementType(objectOrArray.type) + '/>';
                } else if (jsxPropsParents.has(objectOrArray)) {
                    var _type = jsxPropsParents.get(objectOrArray);
                    str = '<' + (describeElementType(_type) || '...');
                    var object = objectOrArray;
                    var names = Object.keys(object);
                    for(var _i2 = 0; _i2 < names.length; _i2++){
                        str += ' ';
                        var name = names[_i2];
                        str += describeKeyForErrorMessage(name) + '=';
                        var _value2 = object[name];
                        var _substr2 = void 0;
                        if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
                            _substr2 = describeObjectForErrorMessage(_value2);
                        } else {
                            _substr2 = describeValueForErrorMessage(_value2);
                        }
                        if (typeof _value2 !== 'string') {
                            _substr2 = '{' + _substr2 + '}';
                        }
                        if (name === expandedName) {
                            start = str.length;
                            length = _substr2.length;
                            str += _substr2;
                        } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {
                            str += _substr2;
                        } else {
                            str += '...';
                        }
                    }
                    str += '>';
                } else {
                    str = '{';
                    var _object = objectOrArray;
                    var _names = Object.keys(_object);
                    for(var _i3 = 0; _i3 < _names.length; _i3++){
                        if (_i3 > 0) {
                            str += ', ';
                        }
                        var _name = _names[_i3];
                        str += describeKeyForErrorMessage(_name) + ': ';
                        var _value3 = _object[_name];
                        var _substr3 = void 0;
                        if (typeof _value3 === 'object' && _value3 !== null) {
                            _substr3 = describeObjectForErrorMessage(_value3);
                        } else {
                            _substr3 = describeValueForErrorMessage(_value3);
                        }
                        if (_name === expandedName) {
                            start = str.length;
                            length = _substr3.length;
                            str += _substr3;
                        } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {
                            str += _substr3;
                        } else {
                            str += '...';
                        }
                    }
                    str += '}';
                }
            }
            if (expandedName === undefined) {
                return str;
            }
            if (start > -1 && length > 0) {
                var highlight = ' '.repeat(start) + '^'.repeat(length);
                return '\n  ' + str + '\n  ' + highlight;
            }
            return '\n  ' + str;
        }
        var ContextRegistry = ReactSharedInternals.ContextRegistry;
        function getOrCreateServerContext(globalName) {
            if (!ContextRegistry[globalName]) {
                ContextRegistry[globalName] = React.createServerContext(globalName, REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED);
            }
            return ContextRegistry[globalName];
        }
        var stringify = JSON.stringify;
        var PENDING$1 = 0;
        var COMPLETED = 1;
        var ABORTED = 3;
        var ERRORED$1 = 4;
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactCurrentCache = ReactSharedInternals.ReactCurrentCache;
        function defaultErrorHandler(error) {
            console['error'](error);
        }
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        function createRequest(model, bundlerConfig, onError, context, identifierPrefix) {
            if (ReactCurrentCache.current !== null && ReactCurrentCache.current !== DefaultCacheDispatcher) {
                throw new Error('Currently React only supports one RSC renderer at a time.');
            }
            prepareHostDispatcher();
            ReactCurrentCache.current = DefaultCacheDispatcher;
            var abortSet = new Set();
            var pingedTasks = [];
            var hints = createHints();
            var request = {
                status: OPEN,
                flushScheduled: false,
                fatalError: null,
                destination: null,
                bundlerConfig: bundlerConfig,
                cache: new Map(),
                nextChunkId: 0,
                pendingChunks: 0,
                hints: hints,
                abortableTasks: abortSet,
                pingedTasks: pingedTasks,
                completedImportChunks: [],
                completedHintChunks: [],
                completedRegularChunks: [],
                completedErrorChunks: [],
                writtenSymbols: new Map(),
                writtenClientReferences: new Map(),
                writtenServerReferences: new Map(),
                writtenProviders: new Map(),
                identifierPrefix: identifierPrefix || '',
                identifierCount: 1,
                onError: onError === undefined ? defaultErrorHandler : onError,
                toJSON: function(key, value) {
                    return resolveModelToJSON(request, this, key, value);
                }
            };
            request.pendingChunks++;
            var rootContext = createRootContext(context);
            var rootTask = createTask(request, model, rootContext, abortSet);
            pingedTasks.push(rootTask);
            return request;
        }
        var currentRequest = null;
        function resolveRequest() {
            if (currentRequest) return currentRequest;
            if (supportsRequestStorage) {
                var store = requestStorage.getStore();
                if (store) return store;
            }
            return null;
        }
        function createRootContext(reqContext) {
            return importServerContexts(reqContext);
        }
        var POP = {};
        function serializeThenable(request, thenable) {
            request.pendingChunks++;
            var newTask = createTask(request, null, getActiveContext(), request.abortableTasks);
            switch(thenable.status){
                case 'fulfilled':
                    {
                        newTask.model = thenable.value;
                        pingTask(request, newTask);
                        return newTask.id;
                    }
                case 'rejected':
                    {
                        var x = thenable.reason;
                        var digest = logRecoverableError(request, x);
                        {
                            var _getErrorMessageAndSt = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt.message, stack = _getErrorMessageAndSt.stack;
                            emitErrorChunkDev(request, newTask.id, digest, message, stack);
                        }
                        return newTask.id;
                    }
                default:
                    {
                        if (typeof thenable.status === 'string') {
                            break;
                        }
                        var pendingThenable = thenable;
                        pendingThenable.status = 'pending';
                        pendingThenable.then(function(fulfilledValue) {
                            if (thenable.status === 'pending') {
                                var fulfilledThenable = thenable;
                                fulfilledThenable.status = 'fulfilled';
                                fulfilledThenable.value = fulfilledValue;
                            }
                        }, function(error) {
                            if (thenable.status === 'pending') {
                                var rejectedThenable = thenable;
                                rejectedThenable.status = 'rejected';
                                rejectedThenable.reason = error;
                            }
                        });
                        break;
                    }
            }
            thenable.then(function(value) {
                newTask.model = value;
                pingTask(request, newTask);
            }, function(reason) {
                newTask.status = ERRORED$1;
                var digest = logRecoverableError(request, reason);
                {
                    var _getErrorMessageAndSt2 = getErrorMessageAndStackDev(reason), _message = _getErrorMessageAndSt2.message, _stack = _getErrorMessageAndSt2.stack;
                    emitErrorChunkDev(request, newTask.id, digest, _message, _stack);
                }
                if (request.destination !== null) {
                    flushCompletedChunks(request, request.destination);
                }
            });
            return newTask.id;
        }
        function emitHint(request, code, model) {
            emitHintChunk(request, code, model);
            enqueueFlush(request);
        }
        function getHints(request) {
            return request.hints;
        }
        function getCache(request) {
            return request.cache;
        }
        function readThenable(thenable) {
            if (thenable.status === 'fulfilled') {
                return thenable.value;
            } else if (thenable.status === 'rejected') {
                throw thenable.reason;
            }
            throw thenable;
        }
        function createLazyWrapperAroundWakeable(wakeable) {
            var thenable = wakeable;
            switch(thenable.status){
                case 'fulfilled':
                case 'rejected':
                    break;
                default:
                    {
                        if (typeof thenable.status === 'string') {
                            break;
                        }
                        var pendingThenable = thenable;
                        pendingThenable.status = 'pending';
                        pendingThenable.then(function(fulfilledValue) {
                            if (thenable.status === 'pending') {
                                var fulfilledThenable = thenable;
                                fulfilledThenable.status = 'fulfilled';
                                fulfilledThenable.value = fulfilledValue;
                            }
                        }, function(error) {
                            if (thenable.status === 'pending') {
                                var rejectedThenable = thenable;
                                rejectedThenable.status = 'rejected';
                                rejectedThenable.reason = error;
                            }
                        });
                        break;
                    }
            }
            var lazyType = {
                $$typeof: REACT_LAZY_TYPE,
                _payload: thenable,
                _init: readThenable
            };
            return lazyType;
        }
        function attemptResolveElement(request, type, key, ref, props, prevThenableState) {
            if (ref !== null && ref !== undefined) {
                throw new Error('Refs cannot be used in Server Components, nor passed to Client Components.');
            }
            {
                jsxPropsParents.set(props, type);
                if (typeof props.children === 'object' && props.children !== null) {
                    jsxChildrenParents.set(props.children, type);
                }
            }
            if (typeof type === 'function') {
                if (isClientReference(type)) {
                    return [
                        REACT_ELEMENT_TYPE,
                        type,
                        key,
                        props
                    ];
                }
                prepareToUseHooksForComponent(prevThenableState);
                var result = type(props);
                if (typeof result === 'object' && result !== null && typeof result.then === 'function') {
                    var thenable = result;
                    if (thenable.status === 'fulfilled') {
                        return thenable.value;
                    }
                    return createLazyWrapperAroundWakeable(result);
                }
                return result;
            } else if (typeof type === 'string') {
                return [
                    REACT_ELEMENT_TYPE,
                    type,
                    key,
                    props
                ];
            } else if (typeof type === 'symbol') {
                if (type === REACT_FRAGMENT_TYPE) {
                    return props.children;
                }
                return [
                    REACT_ELEMENT_TYPE,
                    type,
                    key,
                    props
                ];
            } else if (type != null && typeof type === 'object') {
                if (isClientReference(type)) {
                    return [
                        REACT_ELEMENT_TYPE,
                        type,
                        key,
                        props
                    ];
                }
                switch(type.$$typeof){
                    case REACT_LAZY_TYPE:
                        {
                            var payload = type._payload;
                            var init = type._init;
                            var wrappedType = init(payload);
                            return attemptResolveElement(request, wrappedType, key, ref, props, prevThenableState);
                        }
                    case REACT_FORWARD_REF_TYPE:
                        {
                            var render = type.render;
                            prepareToUseHooksForComponent(prevThenableState);
                            return render(props, undefined);
                        }
                    case REACT_MEMO_TYPE:
                        {
                            return attemptResolveElement(request, type.type, key, ref, props, prevThenableState);
                        }
                    case REACT_PROVIDER_TYPE:
                        {
                            pushProvider(type._context, props.value);
                            {
                                var extraKeys = Object.keys(props).filter(function(value) {
                                    if (value === 'children' || value === 'value') {
                                        return false;
                                    }
                                    return true;
                                });
                                if (extraKeys.length !== 0) {
                                    error('ServerContext can only have a value prop and children. Found: %s', JSON.stringify(extraKeys));
                                }
                            }
                            return [
                                REACT_ELEMENT_TYPE,
                                type,
                                key,
                                {
                                    value: props.value,
                                    children: props.children,
                                    __pop: POP
                                }
                            ];
                        }
                }
            }
            throw new Error("Unsupported Server Component type: " + describeValueForErrorMessage(type));
        }
        function pingTask(request, task) {
            var pingedTasks = request.pingedTasks;
            pingedTasks.push(task);
            if (pingedTasks.length === 1) {
                request.flushScheduled = request.destination !== null;
                scheduleWork(function() {
                    return performWork(request);
                });
            }
        }
        function createTask(request, model, context, abortSet) {
            var id = request.nextChunkId++;
            var task = {
                id: id,
                status: PENDING$1,
                model: model,
                context: context,
                ping: function() {
                    return pingTask(request, task);
                },
                thenableState: null
            };
            abortSet.add(task);
            return task;
        }
        function serializeByValueID(id) {
            return '$' + id.toString(16);
        }
        function serializeLazyID(id) {
            return '$L' + id.toString(16);
        }
        function serializePromiseID(id) {
            return '$@' + id.toString(16);
        }
        function serializeServerReferenceID(id) {
            return '$F' + id.toString(16);
        }
        function serializeSymbolReference(name) {
            return '$S' + name;
        }
        function serializeProviderReference(name) {
            return '$P' + name;
        }
        function serializeNumber(number) {
            if (Number.isFinite(number)) {
                if (number === 0 && 1 / number === -Infinity) {
                    return '$-0';
                } else {
                    return number;
                }
            } else {
                if (number === Infinity) {
                    return '$Infinity';
                } else if (number === -Infinity) {
                    return '$-Infinity';
                } else {
                    return '$NaN';
                }
            }
        }
        function serializeUndefined() {
            return '$undefined';
        }
        function serializeDateFromDateJSON(dateJSON) {
            return '$D' + dateJSON;
        }
        function serializeBigInt(n) {
            return '$n' + n.toString(10);
        }
        function serializeClientReference(request, parent, key, clientReference) {
            var clientReferenceKey = getClientReferenceKey(clientReference);
            var writtenClientReferences = request.writtenClientReferences;
            var existingId = writtenClientReferences.get(clientReferenceKey);
            if (existingId !== undefined) {
                if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
                    return serializeLazyID(existingId);
                }
                return serializeByValueID(existingId);
            }
            try {
                var clientReferenceMetadata = resolveClientReferenceMetadata(request.bundlerConfig, clientReference);
                request.pendingChunks++;
                var importId = request.nextChunkId++;
                emitImportChunk(request, importId, clientReferenceMetadata);
                writtenClientReferences.set(clientReferenceKey, importId);
                if (parent[0] === REACT_ELEMENT_TYPE && key === '1') {
                    return serializeLazyID(importId);
                }
                return serializeByValueID(importId);
            } catch (x) {
                request.pendingChunks++;
                var errorId = request.nextChunkId++;
                var digest = logRecoverableError(request, x);
                {
                    var _getErrorMessageAndSt3 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt3.message, stack = _getErrorMessageAndSt3.stack;
                    emitErrorChunkDev(request, errorId, digest, message, stack);
                }
                return serializeByValueID(errorId);
            }
        }
        function outlineModel(request, value) {
            request.pendingChunks++;
            var outlinedId = request.nextChunkId++;
            var processedChunk = processModelChunk(request, outlinedId, value);
            request.completedRegularChunks.push(processedChunk);
            return outlinedId;
        }
        function serializeServerReference(request, parent, key, serverReference) {
            var writtenServerReferences = request.writtenServerReferences;
            var existingId = writtenServerReferences.get(serverReference);
            if (existingId !== undefined) {
                return serializeServerReferenceID(existingId);
            }
            var bound = getServerReferenceBoundArguments(request.bundlerConfig, serverReference);
            var serverReferenceMetadata = {
                id: getServerReferenceId(request.bundlerConfig, serverReference),
                bound: bound ? Promise.resolve(bound) : null
            };
            var metadataId = outlineModel(request, serverReferenceMetadata);
            writtenServerReferences.set(serverReference, metadataId);
            return serializeServerReferenceID(metadataId);
        }
        function serializeLargeTextString(request, text) {
            request.pendingChunks += 2;
            var textId = request.nextChunkId++;
            var textChunk = stringToChunk(text);
            var headerChunk = processTextHeader(request, textId, byteLengthOfChunk(textChunk));
            request.completedRegularChunks.push(headerChunk, textChunk);
            return serializeByValueID(textId);
        }
        function serializeMap(request, map) {
            var id = outlineModel(request, Array.from(map));
            return '$Q' + id.toString(16);
        }
        function serializeSet(request, set) {
            var id = outlineModel(request, Array.from(set));
            return '$W' + id.toString(16);
        }
        function escapeStringValue(value) {
            if (value[0] === '$') {
                return '$' + value;
            } else {
                return value;
            }
        }
        var insideContextProps = null;
        var isInsideContextValue = false;
        function resolveModelToJSON(request, parent, key, value) {
            {
                var originalValue = parent[key];
                if (typeof originalValue === 'object' && originalValue !== value && !(originalValue instanceof Date)) {
                    if (objectName(originalValue) !== 'Object') {
                        var jsxParentType = jsxChildrenParents.get(parent);
                        if (typeof jsxParentType === 'string') {
                            error('%s objects cannot be rendered as text children. Try formatting it using toString().%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
                        } else {
                            error('Only plain objects can be passed to Client Components from Server Components. ' + '%s objects are not supported.%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
                        }
                    } else {
                        error('Only plain objects can be passed to Client Components from Server Components. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props.%s', describeObjectForErrorMessage(parent, key));
                    }
                }
            }
            switch(value){
                case REACT_ELEMENT_TYPE:
                    return '$';
            }
            {
                if (parent[0] === REACT_ELEMENT_TYPE && parent[1] && parent[1].$$typeof === REACT_PROVIDER_TYPE && key === '3') {
                    insideContextProps = value;
                } else if (insideContextProps === parent && key === 'value') {
                    isInsideContextValue = true;
                } else if (insideContextProps === parent && key === 'children') {
                    isInsideContextValue = false;
                }
            }
            while(typeof value === 'object' && value !== null && (value.$$typeof === REACT_ELEMENT_TYPE || value.$$typeof === REACT_LAZY_TYPE)){
                {
                    if (isInsideContextValue) {
                        error('React elements are not allowed in ServerContext');
                    }
                }
                try {
                    switch(value.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            {
                                var element = value;
                                value = attemptResolveElement(request, element.type, element.key, element.ref, element.props, null);
                                break;
                            }
                        case REACT_LAZY_TYPE:
                            {
                                var payload = value._payload;
                                var init = value._init;
                                value = init(payload);
                                break;
                            }
                    }
                } catch (thrownValue) {
                    var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                        request.pendingChunks++;
                        var newTask = createTask(request, value, getActiveContext(), request.abortableTasks);
                        var ping = newTask.ping;
                        x.then(ping, ping);
                        newTask.thenableState = getThenableStateAfterSuspending();
                        return serializeLazyID(newTask.id);
                    } else {
                        request.pendingChunks++;
                        var errorId = request.nextChunkId++;
                        var digest = logRecoverableError(request, x);
                        {
                            var _getErrorMessageAndSt4 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt4.message, stack = _getErrorMessageAndSt4.stack;
                            emitErrorChunkDev(request, errorId, digest, message, stack);
                        }
                        return serializeLazyID(errorId);
                    }
                }
            }
            if (value === null) {
                return null;
            }
            if (typeof value === 'object') {
                if (isClientReference(value)) {
                    return serializeClientReference(request, parent, key, value);
                } else if (typeof value.then === 'function') {
                    var promiseId = serializeThenable(request, value);
                    return serializePromiseID(promiseId);
                } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
                    var providerKey = value._context._globalName;
                    var writtenProviders = request.writtenProviders;
                    var providerId = writtenProviders.get(key);
                    if (providerId === undefined) {
                        request.pendingChunks++;
                        providerId = request.nextChunkId++;
                        writtenProviders.set(providerKey, providerId);
                        emitProviderChunk(request, providerId, providerKey);
                    }
                    return serializeByValueID(providerId);
                } else if (value === POP) {
                    popProvider();
                    {
                        insideContextProps = null;
                        isInsideContextValue = false;
                    }
                    return undefined;
                }
                if (value instanceof Map) {
                    return serializeMap(request, value);
                }
                if (value instanceof Set) {
                    return serializeSet(request, value);
                }
                if (!isArray(value)) {
                    var iteratorFn = getIteratorFn(value);
                    if (iteratorFn) {
                        return Array.from(value);
                    }
                }
                {
                    if (value !== null && !isArray(value)) {
                        if (objectName(value) !== 'Object') {
                            error('Only plain objects can be passed to Client Components from Server Components. ' + '%s objects are not supported.%s', objectName(value), describeObjectForErrorMessage(parent, key));
                        } else if (!isSimpleObject(value)) {
                            error('Only plain objects can be passed to Client Components from Server Components. ' + 'Classes or other objects with methods are not supported.%s', describeObjectForErrorMessage(parent, key));
                        } else if (Object.getOwnPropertySymbols) {
                            var symbols = Object.getOwnPropertySymbols(value);
                            if (symbols.length > 0) {
                                error('Only plain objects can be passed to Client Components from Server Components. ' + 'Objects with symbol properties like %s are not supported.%s', symbols[0].description, describeObjectForErrorMessage(parent, key));
                            }
                        }
                    }
                }
                return value;
            }
            if (typeof value === 'string') {
                if (value[value.length - 1] === 'Z') {
                    var _originalValue = parent[key];
                    if (_originalValue instanceof Date) {
                        return serializeDateFromDateJSON(value);
                    }
                }
                if (value.length >= 1024) {
                    return serializeLargeTextString(request, value);
                }
                return escapeStringValue(value);
            }
            if (typeof value === 'boolean') {
                return value;
            }
            if (typeof value === 'number') {
                return serializeNumber(value);
            }
            if (typeof value === 'undefined') {
                return serializeUndefined();
            }
            if (typeof value === 'function') {
                if (isClientReference(value)) {
                    return serializeClientReference(request, parent, key, value);
                }
                if (isServerReference(value)) {
                    return serializeServerReference(request, parent, key, value);
                }
                if (/^on[A-Z]/.test(key)) {
                    throw new Error('Event handlers cannot be passed to Client Component props.' + describeObjectForErrorMessage(parent, key) + '\nIf you need interactivity, consider converting part of this to a Client Component.');
                } else {
                    throw new Error('Functions cannot be passed directly to Client Components ' + 'unless you explicitly expose it by marking it with "use server".' + describeObjectForErrorMessage(parent, key));
                }
            }
            if (typeof value === 'symbol') {
                var writtenSymbols = request.writtenSymbols;
                var existingId = writtenSymbols.get(value);
                if (existingId !== undefined) {
                    return serializeByValueID(existingId);
                }
                var name = value.description;
                if (Symbol.for(name) !== value) {
                    throw new Error('Only global symbols received from Symbol.for(...) can be passed to Client Components. ' + ("The symbol Symbol.for(" + value.description + ") cannot be found among global symbols.") + describeObjectForErrorMessage(parent, key));
                }
                request.pendingChunks++;
                var symbolId = request.nextChunkId++;
                emitSymbolChunk(request, symbolId, name);
                writtenSymbols.set(value, symbolId);
                return serializeByValueID(symbolId);
            }
            if (typeof value === 'bigint') {
                return serializeBigInt(value);
            }
            throw new Error("Type " + typeof value + " is not supported in Client Component props." + describeObjectForErrorMessage(parent, key));
        }
        function logRecoverableError(request, error) {
            var onError = request.onError;
            var errorDigest = onError(error);
            if (errorDigest != null && typeof errorDigest !== 'string') {
                throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
            }
            return errorDigest || '';
        }
        function getErrorMessageAndStackDev(error) {
            {
                var message;
                var stack = '';
                try {
                    if (error instanceof Error) {
                        message = String(error.message);
                        stack = String(error.stack);
                    } else {
                        message = 'Error: ' + error;
                    }
                } catch (x) {
                    message = 'An error occurred but serializing the error message failed.';
                }
                return {
                    message: message,
                    stack: stack
                };
            }
        }
        function fatalError(request, error) {
            if (request.destination !== null) {
                request.status = CLOSED;
                closeWithError(request.destination, error);
            } else {
                request.status = CLOSING;
                request.fatalError = error;
            }
        }
        function emitErrorChunkProd(request, id, digest) {
            var processedChunk = processErrorChunkProd();
            request.completedErrorChunks.push(processedChunk);
        }
        function emitErrorChunkDev(request, id, digest, message, stack) {
            var processedChunk = processErrorChunkDev(request, id, digest, message, stack);
            request.completedErrorChunks.push(processedChunk);
        }
        function emitImportChunk(request, id, clientReferenceMetadata) {
            var processedChunk = processImportChunk(request, id, clientReferenceMetadata);
            request.completedImportChunks.push(processedChunk);
        }
        function emitHintChunk(request, code, model) {
            var processedChunk = processHintChunk(request, request.nextChunkId++, code, model);
            request.completedHintChunks.push(processedChunk);
        }
        function emitSymbolChunk(request, id, name) {
            var symbolReference = serializeSymbolReference(name);
            var processedChunk = processReferenceChunk(request, id, symbolReference);
            request.completedImportChunks.push(processedChunk);
        }
        function emitProviderChunk(request, id, contextName) {
            var contextReference = serializeProviderReference(contextName);
            var processedChunk = processReferenceChunk(request, id, contextReference);
            request.completedRegularChunks.push(processedChunk);
        }
        function retryTask(request, task) {
            if (task.status !== PENDING$1) {
                return;
            }
            switchContext(task.context);
            try {
                var value = task.model;
                if (typeof value === 'object' && value !== null && value.$$typeof === REACT_ELEMENT_TYPE) {
                    var element = value;
                    var prevThenableState = task.thenableState;
                    task.model = value;
                    value = attemptResolveElement(request, element.type, element.key, element.ref, element.props, prevThenableState);
                    task.thenableState = null;
                    while(typeof value === 'object' && value !== null && value.$$typeof === REACT_ELEMENT_TYPE){
                        var nextElement = value;
                        task.model = value;
                        value = attemptResolveElement(request, nextElement.type, nextElement.key, nextElement.ref, nextElement.props, null);
                    }
                }
                var processedChunk = processModelChunk(request, task.id, value);
                request.completedRegularChunks.push(processedChunk);
                request.abortableTasks.delete(task);
                task.status = COMPLETED;
            } catch (thrownValue) {
                var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                    var ping = task.ping;
                    x.then(ping, ping);
                    task.thenableState = getThenableStateAfterSuspending();
                    return;
                } else {
                    request.abortableTasks.delete(task);
                    task.status = ERRORED$1;
                    var digest = logRecoverableError(request, x);
                    {
                        var _getErrorMessageAndSt5 = getErrorMessageAndStackDev(x), message = _getErrorMessageAndSt5.message, stack = _getErrorMessageAndSt5.stack;
                        emitErrorChunkDev(request, task.id, digest, message, stack);
                    }
                }
            }
        }
        function performWork(request) {
            var prevDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = HooksDispatcher;
            var prevRequest = currentRequest;
            currentRequest = request;
            prepareToUseHooksForRequest(request);
            try {
                var pingedTasks = request.pingedTasks;
                request.pingedTasks = [];
                for(var i = 0; i < pingedTasks.length; i++){
                    var task = pingedTasks[i];
                    retryTask(request, task);
                }
                if (request.destination !== null) {
                    flushCompletedChunks(request, request.destination);
                }
            } catch (error) {
                logRecoverableError(request, error);
                fatalError(request, error);
            } finally{
                ReactCurrentDispatcher.current = prevDispatcher;
                resetHooksForRequest();
                currentRequest = prevRequest;
            }
        }
        function abortTask(task, request, errorId) {
            task.status = ABORTED;
            var ref = serializeByValueID(errorId);
            var processedChunk = processReferenceChunk(request, task.id, ref);
            request.completedErrorChunks.push(processedChunk);
        }
        function flushCompletedChunks(request, destination) {
            beginWriting();
            try {
                var importsChunks = request.completedImportChunks;
                var i = 0;
                for(; i < importsChunks.length; i++){
                    request.pendingChunks--;
                    var chunk = importsChunks[i];
                    var keepWriting = writeChunkAndReturn(destination, chunk);
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                }
                importsChunks.splice(0, i);
                var hintChunks = request.completedHintChunks;
                i = 0;
                for(; i < hintChunks.length; i++){
                    var _chunk = hintChunks[i];
                    var _keepWriting = writeChunkAndReturn(destination, _chunk);
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                }
                hintChunks.splice(0, i);
                var regularChunks = request.completedRegularChunks;
                i = 0;
                for(; i < regularChunks.length; i++){
                    request.pendingChunks--;
                    var _chunk2 = regularChunks[i];
                    var _keepWriting2 = writeChunkAndReturn(destination, _chunk2);
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                }
                regularChunks.splice(0, i);
                var errorChunks = request.completedErrorChunks;
                i = 0;
                for(; i < errorChunks.length; i++){
                    request.pendingChunks--;
                    var _chunk3 = errorChunks[i];
                    var _keepWriting3 = writeChunkAndReturn(destination, _chunk3);
                    if ("TURBOPACK compile-time falsy", 0) {
                        "TURBOPACK unreachable";
                    }
                }
                errorChunks.splice(0, i);
            } finally{
                request.flushScheduled = false;
                completeWriting(destination);
            }
            if (request.pendingChunks === 0) {
                close$1(destination);
            }
        }
        function startWork(request) {
            request.flushScheduled = request.destination !== null;
            if (supportsRequestStorage) {
                scheduleWork(function() {
                    return requestStorage.run(request, performWork, request);
                });
            } else {
                scheduleWork(function() {
                    return performWork(request);
                });
            }
        }
        function enqueueFlush(request) {
            if (request.flushScheduled === false && request.pingedTasks.length === 0 && request.destination !== null) {
                var destination = request.destination;
                request.flushScheduled = true;
                scheduleWork(function() {
                    return flushCompletedChunks(request, destination);
                });
            }
        }
        function startFlowing(request, destination) {
            if (request.status === CLOSING) {
                request.status = CLOSED;
                closeWithError(destination, request.fatalError);
                return;
            }
            if (request.status === CLOSED) {
                return;
            }
            if (request.destination !== null) {
                return;
            }
            request.destination = destination;
            try {
                flushCompletedChunks(request, destination);
            } catch (error) {
                logRecoverableError(request, error);
                fatalError(request, error);
            }
        }
        function abort(request, reason) {
            try {
                var abortableTasks = request.abortableTasks;
                if (abortableTasks.size > 0) {
                    var error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
                    var digest = logRecoverableError(request, error);
                    request.pendingChunks++;
                    var errorId = request.nextChunkId++;
                    if ("TURBOPACK compile-time truthy", 1) {
                        var _getErrorMessageAndSt6 = getErrorMessageAndStackDev(error), message = _getErrorMessageAndSt6.message, stack = _getErrorMessageAndSt6.stack;
                        emitErrorChunkDev(request, errorId, digest, message, stack);
                    }
                    abortableTasks.forEach(function(task) {
                        return abortTask(task, request, errorId);
                    });
                    abortableTasks.clear();
                }
                if (request.destination !== null) {
                    flushCompletedChunks(request, request.destination);
                }
            } catch (error) {
                logRecoverableError(request, error);
                fatalError(request, error);
            }
        }
        function importServerContexts(contexts) {
            if (contexts) {
                var prevContext = getActiveContext();
                switchContext(rootContextSnapshot);
                for(var i = 0; i < contexts.length; i++){
                    var _contexts$i = contexts[i], name = _contexts$i[0], value = _contexts$i[1];
                    var context = getOrCreateServerContext(name);
                    pushProvider(context, value);
                }
                var importedContext = getActiveContext();
                switchContext(prevContext);
                return importedContext;
            }
            return rootContextSnapshot;
        }
        function serializeRowHeader(tag, id) {
            return id.toString(16) + ':' + tag;
        }
        function processErrorChunkProd(request, id, digest) {
            {
                throw new Error('processErrorChunkProd should never be called while in development mode. Use processErrorChunkDev instead. This is a bug in React.');
            }
        }
        function processErrorChunkDev(request, id, digest, message, stack) {
            var errorInfo = {
                digest: digest,
                message: message,
                stack: stack
            };
            var row = serializeRowHeader('E', id) + stringify(errorInfo) + '\n';
            return stringToChunk(row);
        }
        function processModelChunk(request, id, model) {
            var json = stringify(model, request.toJSON);
            var row = id.toString(16) + ':' + json + '\n';
            return stringToChunk(row);
        }
        function processReferenceChunk(request, id, reference) {
            var json = stringify(reference);
            var row = id.toString(16) + ':' + json + '\n';
            return stringToChunk(row);
        }
        function processImportChunk(request, id, clientReferenceMetadata) {
            var json = stringify(clientReferenceMetadata);
            var row = serializeRowHeader('I', id) + json + '\n';
            return stringToChunk(row);
        }
        function processHintChunk(request, id, code, model) {
            var json = stringify(model);
            var row = serializeRowHeader('H' + code, id) + json + '\n';
            return stringToChunk(row);
        }
        function processTextHeader(request, id, binaryLength) {
            var row = id.toString(16) + ':T' + binaryLength.toString(16) + ',';
            return stringToChunk(row);
        }
        function resolveServerReference(bundlerConfig, id) {
            var name = '';
            var resolvedModuleData = bundlerConfig[id];
            if (resolvedModuleData) {
                name = resolvedModuleData.name;
            } else {
                var idx = id.lastIndexOf('#');
                if (idx !== -1) {
                    name = id.slice(idx + 1);
                    resolvedModuleData = bundlerConfig[id.slice(0, idx)];
                }
                if (!resolvedModuleData) {
                    throw new Error('Could not find the module "' + id + '" in the React Server Manifest. ' + 'This is probably a bug in the React Server Components bundler.');
                }
            }
            return {
                id: resolvedModuleData.id,
                chunks: resolvedModuleData.chunks,
                name: name,
                async: false
            };
        }
        var chunkCache = new Map();
        function requireAsyncModule(id) {
            var promise = globalThis.__next_require__(id);
            if (typeof promise.then !== 'function') {
                return null;
            } else if (promise.status === 'fulfilled') {
                return null;
            } else {
                promise.then(function(value) {
                    var fulfilledThenable = promise;
                    fulfilledThenable.status = 'fulfilled';
                    fulfilledThenable.value = value;
                }, function(reason) {
                    var rejectedThenable = promise;
                    rejectedThenable.status = 'rejected';
                    rejectedThenable.reason = reason;
                });
                return promise;
            }
        }
        function ignoreReject() {}
        function preloadModule(metadata) {
            var chunks = metadata.chunks;
            var promises = [];
            for(var i = 0; i < chunks.length; i++){
                var chunkId = chunks[i];
                var entry = chunkCache.get(chunkId);
                if (entry === undefined) {
                    var thenable = globalThis.__next_chunk_load__(chunkId);
                    promises.push(thenable);
                    var resolve = chunkCache.set.bind(chunkCache, chunkId, null);
                    thenable.then(resolve, ignoreReject);
                    chunkCache.set(chunkId, thenable);
                } else if (entry !== null) {
                    promises.push(entry);
                }
            }
            if (metadata.async) {
                if (promises.length === 0) {
                    return requireAsyncModule(metadata.id);
                } else {
                    return Promise.all(promises).then(function() {
                        return requireAsyncModule(metadata.id);
                    });
                }
            } else if (promises.length > 0) {
                return Promise.all(promises);
            } else {
                return null;
            }
        }
        function requireModule(metadata) {
            var moduleExports = globalThis.__next_require__(metadata.id);
            if (metadata.async) {
                if (typeof moduleExports.then !== 'function') ;
                else if (moduleExports.status === 'fulfilled') {
                    moduleExports = moduleExports.value;
                } else {
                    throw moduleExports.reason;
                }
            }
            if (metadata.name === '*') {
                return moduleExports;
            }
            if (metadata.name === '') {
                return moduleExports.__esModule ? moduleExports.default : moduleExports;
            }
            return moduleExports[metadata.name];
        }
        var PENDING = 'pending';
        var BLOCKED = 'blocked';
        var RESOLVED_MODEL = 'resolved_model';
        var INITIALIZED = 'fulfilled';
        var ERRORED = 'rejected';
        function Chunk(status, value, reason, response) {
            this.status = status;
            this.value = value;
            this.reason = reason;
            this._response = response;
        }
        Chunk.prototype = Object.create(Promise.prototype);
        Chunk.prototype.then = function(resolve, reject) {
            var chunk = this;
            switch(chunk.status){
                case RESOLVED_MODEL:
                    initializeModelChunk(chunk);
                    break;
            }
            switch(chunk.status){
                case INITIALIZED:
                    resolve(chunk.value);
                    break;
                case PENDING:
                case BLOCKED:
                    if (resolve) {
                        if (chunk.value === null) {
                            chunk.value = [];
                        }
                        chunk.value.push(resolve);
                    }
                    if (reject) {
                        if (chunk.reason === null) {
                            chunk.reason = [];
                        }
                        chunk.reason.push(reject);
                    }
                    break;
                default:
                    reject(chunk.reason);
                    break;
            }
        };
        function getRoot(response) {
            var chunk = getChunk(response, 0);
            return chunk;
        }
        function createPendingChunk(response) {
            return new Chunk(PENDING, null, null, response);
        }
        function wakeChunk(listeners, value) {
            for(var i = 0; i < listeners.length; i++){
                var listener = listeners[i];
                listener(value);
            }
        }
        function triggerErrorOnChunk(chunk, error) {
            if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
                return;
            }
            var listeners = chunk.reason;
            var erroredChunk = chunk;
            erroredChunk.status = ERRORED;
            erroredChunk.reason = error;
            if (listeners !== null) {
                wakeChunk(listeners, error);
            }
        }
        function createResolvedModelChunk(response, value) {
            return new Chunk(RESOLVED_MODEL, value, null, response);
        }
        function bindArgs$1(fn, args) {
            return fn.bind.apply(fn, [
                null
            ].concat(args));
        }
        function loadServerReference$1(response, id, bound, parentChunk, parentObject, key) {
            var serverReference = resolveServerReference(response._bundlerConfig, id);
            var preloadPromise = preloadModule(serverReference);
            var promise;
            if (bound) {
                promise = Promise.all([
                    bound,
                    preloadPromise
                ]).then(function(_ref) {
                    var args = _ref[0];
                    return bindArgs$1(requireModule(serverReference), args);
                });
            } else {
                if (preloadPromise) {
                    promise = Promise.resolve(preloadPromise).then(function() {
                        return requireModule(serverReference);
                    });
                } else {
                    return requireModule(serverReference);
                }
            }
            promise.then(createModelResolver(parentChunk, parentObject, key), createModelReject(parentChunk));
            return null;
        }
        var initializingChunk = null;
        var initializingChunkBlockedModel = null;
        function initializeModelChunk(chunk) {
            var prevChunk = initializingChunk;
            var prevBlocked = initializingChunkBlockedModel;
            initializingChunk = chunk;
            initializingChunkBlockedModel = null;
            try {
                var value = JSON.parse(chunk.value, chunk._response._fromJSON);
                if (initializingChunkBlockedModel !== null && initializingChunkBlockedModel.deps > 0) {
                    initializingChunkBlockedModel.value = value;
                    var blockedChunk = chunk;
                    blockedChunk.status = BLOCKED;
                    blockedChunk.value = null;
                    blockedChunk.reason = null;
                } else {
                    var initializedChunk = chunk;
                    initializedChunk.status = INITIALIZED;
                    initializedChunk.value = value;
                }
            } catch (error) {
                var erroredChunk = chunk;
                erroredChunk.status = ERRORED;
                erroredChunk.reason = error;
            } finally{
                initializingChunk = prevChunk;
                initializingChunkBlockedModel = prevBlocked;
            }
        }
        function reportGlobalError(response, error) {
            response._chunks.forEach(function(chunk) {
                if (chunk.status === PENDING) {
                    triggerErrorOnChunk(chunk, error);
                }
            });
        }
        function getChunk(response, id) {
            var chunks = response._chunks;
            var chunk = chunks.get(id);
            if (!chunk) {
                var prefix = response._prefix;
                var key = prefix + id;
                var backingEntry = response._formData.get(key);
                if (backingEntry != null) {
                    chunk = createResolvedModelChunk(response, backingEntry);
                } else {
                    chunk = createPendingChunk(response);
                }
                chunks.set(id, chunk);
            }
            return chunk;
        }
        function createModelResolver(chunk, parentObject, key) {
            var blocked;
            if (initializingChunkBlockedModel) {
                blocked = initializingChunkBlockedModel;
                blocked.deps++;
            } else {
                blocked = initializingChunkBlockedModel = {
                    deps: 1,
                    value: null
                };
            }
            return function(value) {
                parentObject[key] = value;
                blocked.deps--;
                if (blocked.deps === 0) {
                    if (chunk.status !== BLOCKED) {
                        return;
                    }
                    var resolveListeners = chunk.value;
                    var initializedChunk = chunk;
                    initializedChunk.status = INITIALIZED;
                    initializedChunk.value = blocked.value;
                    if (resolveListeners !== null) {
                        wakeChunk(resolveListeners, blocked.value);
                    }
                }
            };
        }
        function createModelReject(chunk) {
            return function(error) {
                return triggerErrorOnChunk(chunk, error);
            };
        }
        function getOutlinedModel(response, id) {
            var chunk = getChunk(response, id);
            if (chunk.status === RESOLVED_MODEL) {
                initializeModelChunk(chunk);
            }
            if (chunk.status !== INITIALIZED) {
                throw chunk.reason;
            }
            return chunk.value;
        }
        function parseModelString(response, parentObject, key, value) {
            if (value[0] === '$') {
                switch(value[1]){
                    case '$':
                        {
                            return value.slice(1);
                        }
                    case '@':
                        {
                            var id = parseInt(value.slice(2), 16);
                            var chunk = getChunk(response, id);
                            return chunk;
                        }
                    case 'S':
                        {
                            return Symbol.for(value.slice(2));
                        }
                    case 'F':
                        {
                            var _id = parseInt(value.slice(2), 16);
                            var metaData = getOutlinedModel(response, _id);
                            return loadServerReference$1(response, metaData.id, metaData.bound, initializingChunk, parentObject, key);
                        }
                    case 'Q':
                        {
                            var _id2 = parseInt(value.slice(2), 16);
                            var data = getOutlinedModel(response, _id2);
                            return new Map(data);
                        }
                    case 'W':
                        {
                            var _id3 = parseInt(value.slice(2), 16);
                            var _data = getOutlinedModel(response, _id3);
                            return new Set(_data);
                        }
                    case 'K':
                        {
                            var stringId = value.slice(2);
                            var formPrefix = response._prefix + stringId + '_';
                            var _data2 = new FormData();
                            var backingFormData = response._formData;
                            backingFormData.forEach(function(entry, entryKey) {
                                if (entryKey.startsWith(formPrefix)) {
                                    _data2.append(entryKey.slice(formPrefix.length), entry);
                                }
                            });
                            return _data2;
                        }
                    case 'I':
                        {
                            return Infinity;
                        }
                    case '-':
                        {
                            if (value === '$-0') {
                                return -0;
                            } else {
                                return -Infinity;
                            }
                        }
                    case 'N':
                        {
                            return NaN;
                        }
                    case 'u':
                        {
                            return undefined;
                        }
                    case 'D':
                        {
                            return new Date(Date.parse(value.slice(2)));
                        }
                    case 'n':
                        {
                            return BigInt(value.slice(2));
                        }
                    default:
                        {
                            var _id4 = parseInt(value.slice(1), 16);
                            var _chunk = getChunk(response, _id4);
                            switch(_chunk.status){
                                case RESOLVED_MODEL:
                                    initializeModelChunk(_chunk);
                                    break;
                            }
                            switch(_chunk.status){
                                case INITIALIZED:
                                    return _chunk.value;
                                case PENDING:
                                case BLOCKED:
                                    var parentChunk = initializingChunk;
                                    _chunk.then(createModelResolver(parentChunk, parentObject, key), createModelReject(parentChunk));
                                    return null;
                                default:
                                    throw _chunk.reason;
                            }
                        }
                }
            }
            return value;
        }
        function createResponse(bundlerConfig, formFieldPrefix) {
            var backingFormData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new FormData();
            var chunks = new Map();
            var response = {
                _bundlerConfig: bundlerConfig,
                _prefix: formFieldPrefix,
                _formData: backingFormData,
                _chunks: chunks,
                _fromJSON: function(key, value) {
                    if (typeof value === 'string') {
                        return parseModelString(response, this, key, value);
                    }
                    return value;
                }
            };
            return response;
        }
        function close(response) {
            reportGlobalError(response, new Error('Connection closed.'));
        }
        function bindArgs(fn, args) {
            return fn.bind.apply(fn, [
                null
            ].concat(args));
        }
        function loadServerReference(bundlerConfig, id, bound) {
            var serverReference = resolveServerReference(bundlerConfig, id);
            var preloadPromise = preloadModule(serverReference);
            if (bound) {
                return Promise.all([
                    bound,
                    preloadPromise
                ]).then(function(_ref) {
                    var args = _ref[0];
                    return bindArgs(requireModule(serverReference), args);
                });
            } else if (preloadPromise) {
                return Promise.resolve(preloadPromise).then(function() {
                    return requireModule(serverReference);
                });
            } else {
                return Promise.resolve(requireModule(serverReference));
            }
        }
        function decodeAction(body, serverManifest) {
            var formData = new FormData();
            var action = null;
            body.forEach(function(value, key) {
                if (!key.startsWith('$ACTION_')) {
                    formData.append(key, value);
                    return;
                }
                if (key.startsWith('$ACTION_REF_')) {
                    var formFieldPrefix = '$ACTION_' + key.slice(12) + ':';
                    var actionResponse = createResponse(serverManifest, formFieldPrefix, body);
                    close(actionResponse);
                    var refPromise = getRoot(actionResponse);
                    refPromise.then(function() {});
                    if (refPromise.status !== 'fulfilled') {
                        throw refPromise.reason;
                    }
                    var metaData = refPromise.value;
                    action = loadServerReference(serverManifest, metaData.id, metaData.bound);
                    return;
                }
                if (key.startsWith('$ACTION_ID_')) {
                    var id = key.slice(11);
                    action = loadServerReference(serverManifest, id, null);
                    return;
                }
            });
            if (action === null) {
                return null;
            }
            return action.then(function(fn) {
                return fn.bind(null, formData);
            });
        }
        function renderToReadableStream(model, webpackMap, options) {
            var request = createRequest(model, webpackMap, options ? options.onError : undefined, options ? options.context : undefined, options ? options.identifierPrefix : undefined);
            if (options && options.signal) {
                var signal = options.signal;
                if (signal.aborted) {
                    abort(request, signal.reason);
                } else {
                    var listener = function() {
                        abort(request, signal.reason);
                        signal.removeEventListener('abort', listener);
                    };
                    signal.addEventListener('abort', listener);
                }
            }
            var stream = new ReadableStream({
                type: 'bytes',
                start: function(controller) {
                    startWork(request);
                },
                pull: function(controller) {
                    startFlowing(request, controller);
                },
                cancel: function(reason) {}
            }, {
                highWaterMark: 0
            });
            return stream;
        }
        function decodeReply(body, webpackMap) {
            if (typeof body === 'string') {
                var form = new FormData();
                form.append('0', body);
                body = form;
            }
            var response = createResponse(webpackMap, '', body);
            close(response);
            return getRoot(response);
        }
        exports.createClientModuleProxy = createClientModuleProxy;
        exports.decodeAction = decodeAction;
        exports.decodeReply = decodeReply;
        exports.registerClientReference = registerClientReference;
        exports.registerServerReference = registerServerReference;
        exports.renderToReadableStream = renderToReadableStream;
    })();
}

}.call(this) }),
"[project]/node_modules/next/dist/compiled/react-server-dom-webpack/server.edge.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js (ecmascript, rsc)");
}

}.call(this) }),
"[project]/node_modules/next/dist/build/polyfills/process.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
var _global_process, _global_process1;
module.exports = ((_global_process = global.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = global.process) == null ? void 0 : _global_process1.env) === "object" ? global.process : __turbopack_require__("[project]/node_modules/next/dist/compiled/process/browser.js (ecmascript, rsc)");

}.call(this) }),
"[project]/node_modules/next/dist/server/api-utils/index.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getCookieParser: null,
    sendStatusCode: null,
    redirect: null,
    checkIsOnDemandRevalidate: null,
    COOKIE_NAME_PRERENDER_BYPASS: null,
    COOKIE_NAME_PRERENDER_DATA: null,
    RESPONSE_LIMIT_DEFAULT: null,
    SYMBOL_PREVIEW_DATA: null,
    SYMBOL_CLEARED_COOKIES: null,
    clearPreviewData: null,
    ApiError: null,
    sendError: null,
    setLazyProp: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getCookieParser: function() {
        return getCookieParser;
    },
    sendStatusCode: function() {
        return sendStatusCode;
    },
    redirect: function() {
        return redirect;
    },
    checkIsOnDemandRevalidate: function() {
        return checkIsOnDemandRevalidate;
    },
    COOKIE_NAME_PRERENDER_BYPASS: function() {
        return COOKIE_NAME_PRERENDER_BYPASS;
    },
    COOKIE_NAME_PRERENDER_DATA: function() {
        return COOKIE_NAME_PRERENDER_DATA;
    },
    RESPONSE_LIMIT_DEFAULT: function() {
        return RESPONSE_LIMIT_DEFAULT;
    },
    SYMBOL_PREVIEW_DATA: function() {
        return SYMBOL_PREVIEW_DATA;
    },
    SYMBOL_CLEARED_COOKIES: function() {
        return SYMBOL_CLEARED_COOKIES;
    },
    clearPreviewData: function() {
        return clearPreviewData;
    },
    ApiError: function() {
        return ApiError;
    },
    sendError: function() {
        return sendError;
    },
    setLazyProp: function() {
        return setLazyProp;
    }
});
const _headers = __turbopack_require__("[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js (ecmascript, rsc)");
const _constants = __turbopack_require__("[project]/node_modules/next/dist/lib/constants.js (ecmascript, rsc)");
function getCookieParser(headers) {
    return function parseCookie() {
        const { cookie } = headers;
        if (!cookie) {
            return {};
        }
        const { parse: parseCookieFn } = __turbopack_require__("[project]/node_modules/next/dist/compiled/cookie/index.js (ecmascript, rsc)");
        return parseCookieFn(Array.isArray(cookie) ? cookie.join("; ") : cookie);
    };
}
function sendStatusCode(res, statusCode) {
    res.statusCode = statusCode;
    return res;
}
function redirect(res, statusOrUrl, url) {
    if (typeof statusOrUrl === "string") {
        url = statusOrUrl;
        statusOrUrl = 307;
    }
    if (typeof statusOrUrl !== "number" || typeof url !== "string") {
        throw new Error(`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`);
    }
    res.writeHead(statusOrUrl, {
        Location: url
    });
    res.write(url);
    res.end();
    return res;
}
function checkIsOnDemandRevalidate(req, previewProps) {
    const headers = _headers.HeadersAdapter.from(req.headers);
    const previewModeId = headers.get(_constants.PRERENDER_REVALIDATE_HEADER);
    const isOnDemandRevalidate = previewModeId === previewProps.previewModeId;
    const revalidateOnlyGenerated = headers.has(_constants.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER);
    return {
        isOnDemandRevalidate,
        revalidateOnlyGenerated
    };
}
const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`;
const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`;
const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024;
const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA);
const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS);
function clearPreviewData(res, options = {}) {
    if (SYMBOL_CLEARED_COOKIES in res) {
        return res;
    }
    const { serialize } = __turbopack_require__("[project]/node_modules/next/dist/compiled/cookie/index.js (ecmascript, rsc)");
    const previous = res.getHeader("Set-Cookie");
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(COOKIE_NAME_PRERENDER_BYPASS, "", {
            expires: new Date(0),
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        }),
        serialize(COOKIE_NAME_PRERENDER_DATA, "", {
            expires: new Date(0),
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        })
    ]);
    Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {
        value: true,
        enumerable: false
    });
    return res;
}
class ApiError extends Error {
    constructor(statusCode, message){
        super(message);
        this.statusCode = statusCode;
    }
}
function sendError(res, statusCode, message) {
    res.statusCode = statusCode;
    res.statusMessage = message;
    res.end(message);
}
function setLazyProp({ req }, prop, getter) {
    const opts = {
        configurable: true,
        enumerable: true
    };
    const optsReset = {
        ...opts,
        writable: true
    };
    Object.defineProperty(req, prop, {
        ...opts,
        get: ()=>{
            const value = getter();
            Object.defineProperty(req, prop, {
                ...optsReset,
                value
            });
            return value;
        },
        set: (value)=>{
            Object.defineProperty(req, prop, {
                ...optsReset,
                value
            });
        }
    });
}

}.call(this) }),
"[project]/node_modules/next/dist/server/api-utils/node.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    tryGetPreviewData: null,
    parseBody: null,
    apiResolver: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    tryGetPreviewData: function() {
        return tryGetPreviewData;
    },
    parseBody: function() {
        return parseBody;
    },
    apiResolver: function() {
        return apiResolver;
    }
});
const _ = __turbopack_require__("[project]/node_modules/next/dist/server/api-utils/index.js (ecmascript, rsc)");
const _bytes = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/compiled/bytes/index.js (ecmascript, rsc)"));
const _etag = __turbopack_require__("[project]/node_modules/next/dist/server/lib/etag.js (ecmascript, rsc)");
const _sendpayload = __turbopack_require__("[project]/node_modules/next/dist/server/send-payload/index.js (ecmascript, rsc)");
const _stream = __turbopack_external_require__("stream");
const _contenttype = __turbopack_require__("[project]/node_modules/next/dist/compiled/content-type/index.js (ecmascript, rsc)");
const _iserror = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/lib/is-error.js (ecmascript, rsc)"));
const _utils = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/utils.js (ecmascript, rsc)");
const _interopdefault = __turbopack_require__("[project]/node_modules/next/dist/lib/interop-default.js (ecmascript, rsc)");
const _index = __turbopack_require__("[project]/node_modules/next/dist/server/api-utils/index.js (ecmascript, rsc)");
const _tracer = __turbopack_require__("[project]/node_modules/next/dist/server/lib/trace/tracer.js (ecmascript, rsc)");
const _constants = __turbopack_require__("[project]/node_modules/next/dist/server/lib/trace/constants.js (ecmascript, rsc)");
const _cookies = __turbopack_require__("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js (ecmascript, rsc)");
const _headers = __turbopack_require__("[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js (ecmascript, rsc)");
const _constants1 = __turbopack_require__("[project]/node_modules/next/dist/lib/constants.js (ecmascript, rsc)");
const _invokerequest = __turbopack_require__("[project]/node_modules/next/dist/server/lib/server-ipc/invoke-request.js (ecmascript, rsc)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function tryGetPreviewData(req, res, options) {
    var _cookies_get, _cookies_get1;
    if (options && (0, _.checkIsOnDemandRevalidate)(req, options).isOnDemandRevalidate) {
        return false;
    }
    if (_index.SYMBOL_PREVIEW_DATA in req) {
        return req[_index.SYMBOL_PREVIEW_DATA];
    }
    const headers = _headers.HeadersAdapter.from(req.headers);
    const cookies = new _cookies.RequestCookies(headers);
    const previewModeId = (_cookies_get = cookies.get(_index.COOKIE_NAME_PRERENDER_BYPASS)) == null ? void 0 : _cookies_get.value;
    const tokenPreviewData = (_cookies_get1 = cookies.get(_index.COOKIE_NAME_PRERENDER_DATA)) == null ? void 0 : _cookies_get1.value;
    if (previewModeId && !tokenPreviewData && previewModeId === options.previewModeId) {
        const data = {};
        Object.defineProperty(req, _index.SYMBOL_PREVIEW_DATA, {
            value: data,
            enumerable: false
        });
        return data;
    }
    if (!previewModeId && !tokenPreviewData) {
        return false;
    }
    if (!previewModeId || !tokenPreviewData) {
        (0, _index.clearPreviewData)(res);
        return false;
    }
    if (previewModeId !== options.previewModeId) {
        (0, _index.clearPreviewData)(res);
        return false;
    }
    let encryptedPreviewData;
    try {
        const jsonwebtoken = __turbopack_require__("[project]/node_modules/next/dist/compiled/jsonwebtoken/index.js (ecmascript, rsc)");
        encryptedPreviewData = jsonwebtoken.verify(tokenPreviewData, options.previewModeSigningKey);
    } catch  {
        (0, _index.clearPreviewData)(res);
        return false;
    }
    const { decryptWithSecret } = __turbopack_require__("[project]/node_modules/next/dist/server/crypto-utils.js (ecmascript, rsc)");
    const decryptedPreviewData = decryptWithSecret(Buffer.from(options.previewModeEncryptionKey), encryptedPreviewData.data);
    try {
        const data = JSON.parse(decryptedPreviewData);
        Object.defineProperty(req, _index.SYMBOL_PREVIEW_DATA, {
            value: data,
            enumerable: false
        });
        return data;
    } catch  {
        return false;
    }
}
function parseJson(str) {
    if (str.length === 0) {
        return {};
    }
    try {
        return JSON.parse(str);
    } catch (e) {
        throw new _index.ApiError(400, "Invalid JSON");
    }
}
async function parseBody(req, limit) {
    let contentType;
    try {
        contentType = (0, _contenttype.parse)(req.headers["content-type"] || "text/plain");
    } catch  {
        contentType = (0, _contenttype.parse)("text/plain");
    }
    const { type, parameters } = contentType;
    const encoding = parameters.charset || "utf-8";
    let buffer;
    try {
        const getRawBody = __turbopack_require__("[project]/node_modules/next/dist/compiled/raw-body/index.js (ecmascript, rsc)");
        buffer = await getRawBody(req, {
            encoding,
            limit
        });
    } catch (e) {
        if ((0, _iserror.default)(e) && e.type === "entity.too.large") {
            throw new _index.ApiError(413, `Body exceeded ${limit} limit`);
        } else {
            throw new _index.ApiError(400, "Invalid body");
        }
    }
    const body = buffer.toString();
    if (type === "application/json" || type === "application/ld+json") {
        return parseJson(body);
    } else if (type === "application/x-www-form-urlencoded") {
        const qs = __turbopack_external_require__("querystring");
        return qs.decode(body);
    } else {
        return body;
    }
}
function getMaxContentLength(responseLimit) {
    if (responseLimit && typeof responseLimit !== "boolean") {
        return _bytes.default.parse(responseLimit);
    }
    return _index.RESPONSE_LIMIT_DEFAULT;
}
function sendData(req, res, body) {
    if (body === null || body === undefined) {
        res.end();
        return;
    }
    if (res.statusCode === 204 || res.statusCode === 304) {
        res.removeHeader("Content-Type");
        res.removeHeader("Content-Length");
        res.removeHeader("Transfer-Encoding");
        if (process.env.NODE_ENV === "development" && body) {
            console.warn(`A body was attempted to be set with a 204 statusCode for ${req.url}, this is invalid and the body was ignored.\n` + `See more info here https://nextjs.org/docs/messages/invalid-api-status-body`);
        }
        res.end();
        return;
    }
    const contentType = res.getHeader("Content-Type");
    if (body instanceof _stream.Stream) {
        if (!contentType) {
            res.setHeader("Content-Type", "application/octet-stream");
        }
        body.pipe(res);
        return;
    }
    const isJSONLike = [
        "object",
        "number",
        "boolean"
    ].includes(typeof body);
    const stringifiedBody = isJSONLike ? JSON.stringify(body) : body;
    const etag = (0, _etag.generateETag)(stringifiedBody);
    if ((0, _sendpayload.sendEtagResponse)(req, res, etag)) {
        return;
    }
    if (Buffer.isBuffer(body)) {
        if (!contentType) {
            res.setHeader("Content-Type", "application/octet-stream");
        }
        res.setHeader("Content-Length", body.length);
        res.end(body);
        return;
    }
    if (isJSONLike) {
        res.setHeader("Content-Type", "application/json; charset=utf-8");
    }
    res.setHeader("Content-Length", Buffer.byteLength(stringifiedBody));
    res.end(stringifiedBody);
}
function sendJson(res, jsonBody) {
    res.setHeader("Content-Type", "application/json; charset=utf-8");
    res.send(JSON.stringify(jsonBody));
}
function isValidData(str) {
    return typeof str === "string" && str.length >= 16;
}
function setDraftMode(res, options) {
    if (!isValidData(options.previewModeId)) {
        throw new Error("invariant: invalid previewModeId");
    }
    const expires = options.enable ? undefined : new Date(0);
    const { serialize } = __turbopack_require__("[project]/node_modules/next/dist/compiled/cookie/index.js (ecmascript, rsc)");
    const previous = res.getHeader("Set-Cookie");
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(_index.COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            expires
        })
    ]);
    return res;
}
function setPreviewData(res, data, options) {
    if (!isValidData(options.previewModeId)) {
        throw new Error("invariant: invalid previewModeId");
    }
    if (!isValidData(options.previewModeEncryptionKey)) {
        throw new Error("invariant: invalid previewModeEncryptionKey");
    }
    if (!isValidData(options.previewModeSigningKey)) {
        throw new Error("invariant: invalid previewModeSigningKey");
    }
    const jsonwebtoken = __turbopack_require__("[project]/node_modules/next/dist/compiled/jsonwebtoken/index.js (ecmascript, rsc)");
    const { encryptWithSecret } = __turbopack_require__("[project]/node_modules/next/dist/server/crypto-utils.js (ecmascript, rsc)");
    const payload = jsonwebtoken.sign({
        data: encryptWithSecret(Buffer.from(options.previewModeEncryptionKey), JSON.stringify(data))
    }, options.previewModeSigningKey, {
        algorithm: "HS256",
        ...options.maxAge !== undefined ? {
            expiresIn: options.maxAge
        } : undefined
    });
    if (payload.length > 2048) {
        throw new Error(`Preview data is limited to 2KB currently, reduce how much data you are storing as preview data to continue`);
    }
    const { serialize } = __turbopack_require__("[project]/node_modules/next/dist/compiled/cookie/index.js (ecmascript, rsc)");
    const previous = res.getHeader("Set-Cookie");
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(_index.COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            ...options.maxAge !== undefined ? {
                maxAge: options.maxAge
            } : undefined,
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        }),
        serialize(_index.COOKIE_NAME_PRERENDER_DATA, payload, {
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            ...options.maxAge !== undefined ? {
                maxAge: options.maxAge
            } : undefined,
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        })
    ]);
    return res;
}
async function revalidate(urlPath, opts, req, context) {
    if (typeof urlPath !== "string" || !urlPath.startsWith("/")) {
        throw new Error(`Invalid urlPath provided to revalidate(), must be a path e.g. /blog/post-1, received ${urlPath}`);
    }
    const revalidateHeaders = {
        [_constants1.PRERENDER_REVALIDATE_HEADER]: context.previewModeId,
        ...opts.unstable_onlyGenerated ? {
            [_constants1.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER]: "1"
        } : {}
    };
    const allowedRevalidateHeaderKeys = [
        ...context.allowedRevalidateHeaderKeys || [],
        ...context.trustHostHeader ? [
            "cookie",
            "x-vercel-protection-bypass"
        ] : []
    ];
    for (const key of Object.keys(req.headers)){
        if (allowedRevalidateHeaderKeys.includes(key)) {
            revalidateHeaders[key] = req.headers[key];
        }
    }
    try {
        if (context.trustHostHeader) {
            const res = await fetch(`https://${req.headers.host}${urlPath}`, {
                method: "HEAD",
                headers: revalidateHeaders
            });
            const cacheHeader = res.headers.get("x-vercel-cache") || res.headers.get("x-nextjs-cache");
            if ((cacheHeader == null ? void 0 : cacheHeader.toUpperCase()) !== "REVALIDATED" && !(res.status === 404 && opts.unstable_onlyGenerated)) {
                throw new Error(`Invalid response ${res.status}`);
            }
        } else if (context.revalidate) {
            const ipcPort = process.env.__NEXT_PRIVATE_ROUTER_IPC_PORT;
            if (ipcPort) {
                const ipcKey = process.env.__NEXT_PRIVATE_ROUTER_IPC_KEY;
                const res = await (0, _invokerequest.invokeRequest)(`http://${context.hostname}:${ipcPort}?key=${ipcKey}&method=revalidate&args=${encodeURIComponent(JSON.stringify([
                    {
                        urlPath,
                        revalidateHeaders,
                        opts
                    }
                ]))}`, {
                    method: "GET",
                    headers: {}
                });
                const chunks = [];
                for await (const chunk of res){
                    if (chunk) {
                        chunks.push(chunk);
                    }
                }
                const body = Buffer.concat(chunks).toString();
                const result = JSON.parse(body);
                if (result.err) {
                    throw new Error(result.err.message);
                }
                return;
            }
            await context.revalidate({
                urlPath,
                revalidateHeaders,
                opts
            });
        } else {
            throw new Error(`Invariant: required internal revalidate method not passed to api-utils`);
        }
    } catch (err) {
        throw new Error(`Failed to revalidate ${urlPath}: ${(0, _iserror.default)(err) ? err.message : err}`);
    }
}
async function apiResolver(req, res, query, resolverModule, apiContext, propagateError, dev, page) {
    const apiReq = req;
    const apiRes = res;
    try {
        var _config_api, _config_api1, _config_api2, _getTracer_getRootSpanAttributes;
        if (!resolverModule) {
            res.statusCode = 404;
            res.end("Not Found");
            return;
        }
        const config = resolverModule.config || {};
        const bodyParser = ((_config_api = config.api) == null ? void 0 : _config_api.bodyParser) !== false;
        const responseLimit = ((_config_api1 = config.api) == null ? void 0 : _config_api1.responseLimit) ?? true;
        const externalResolver = ((_config_api2 = config.api) == null ? void 0 : _config_api2.externalResolver) || false;
        (0, _index.setLazyProp)({
            req: apiReq
        }, "cookies", (0, _index.getCookieParser)(req.headers));
        apiReq.query = query;
        (0, _index.setLazyProp)({
            req: apiReq
        }, "previewData", ()=>tryGetPreviewData(req, res, apiContext));
        (0, _index.setLazyProp)({
            req: apiReq
        }, "preview", ()=>apiReq.previewData !== false ? true : undefined);
        (0, _index.setLazyProp)({
            req: apiReq
        }, "draftMode", ()=>apiReq.preview);
        if (bodyParser && !apiReq.body) {
            apiReq.body = await parseBody(apiReq, config.api && config.api.bodyParser && config.api.bodyParser.sizeLimit ? config.api.bodyParser.sizeLimit : "1mb");
        }
        let contentLength = 0;
        const maxContentLength = getMaxContentLength(responseLimit);
        const writeData = apiRes.write;
        const endResponse = apiRes.end;
        apiRes.write = (...args)=>{
            contentLength += Buffer.byteLength(args[0] || "");
            return writeData.apply(apiRes, args);
        };
        apiRes.end = (...args)=>{
            if (args.length && typeof args[0] !== "function") {
                contentLength += Buffer.byteLength(args[0] || "");
            }
            if (responseLimit && contentLength >= maxContentLength) {
                console.warn(`API response for ${req.url} exceeds ${_bytes.default.format(maxContentLength)}. API Routes are meant to respond quickly. https://nextjs.org/docs/messages/api-routes-response-size-limit`);
            }
            return endResponse.apply(apiRes, args);
        };
        apiRes.status = (statusCode)=>(0, _index.sendStatusCode)(apiRes, statusCode);
        apiRes.send = (data)=>sendData(apiReq, apiRes, data);
        apiRes.json = (data)=>sendJson(apiRes, data);
        apiRes.redirect = (statusOrUrl, url)=>(0, _index.redirect)(apiRes, statusOrUrl, url);
        apiRes.setDraftMode = (options = {
            enable: true
        })=>setDraftMode(apiRes, Object.assign({}, apiContext, options));
        apiRes.setPreviewData = (data, options = {})=>setPreviewData(apiRes, data, Object.assign({}, apiContext, options));
        apiRes.clearPreviewData = (options = {})=>(0, _index.clearPreviewData)(apiRes, options);
        apiRes.revalidate = (urlPath, opts)=>revalidate(urlPath, opts || {}, req, apiContext);
        const resolver = (0, _interopdefault.interopDefault)(resolverModule);
        let wasPiped = false;
        if ("TURBOPACK compile-time truthy", 1) {
            res.once("pipe", ()=>wasPiped = true);
        }
        (_getTracer_getRootSpanAttributes = (0, _tracer.getTracer)().getRootSpanAttributes()) == null ? void 0 : _getTracer_getRootSpanAttributes.set("next.route", page);
        const apiRouteResult = await (0, _tracer.getTracer)().trace(_constants.NodeSpan.runHandler, {
            spanName: `executing api route (pages) ${page}`
        }, ()=>resolver(req, res));
        if ("TURBOPACK compile-time truthy", 1) {
            if (typeof apiRouteResult !== "undefined") {
                if (apiRouteResult instanceof Response) {
                    throw new Error('API route returned a Response object in the Node.js runtime, this is not supported. Please use `runtime: "edge"` instead: https://nextjs.org/docs/api-routes/edge-api-routes');
                }
                console.warn(`API handler should not return a value, received ${typeof apiRouteResult}.`);
            }
            if (!externalResolver && !(0, _utils.isResSent)(res) && !wasPiped) {
                console.warn(`API resolved without sending a response for ${req.url}, this may result in stalled requests.`);
            }
        }
    } catch (err) {
        if (err instanceof _index.ApiError) {
            (0, _index.sendError)(apiRes, err.statusCode, err.message);
        } else {
            if (dev) {
                if ((0, _iserror.default)(err)) {
                    err.page = page;
                }
                throw err;
            }
            console.error(err);
            if (propagateError) {
                throw err;
            }
            (0, _index.sendError)(apiRes, 500, "Internal Server Error");
        }
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createProxy", {
    enumerable: true,
    get: function() {
        return createProxy;
    }
});
const CLIENT_REFERENCE = Symbol.for("react.client.reference");
const PROMISE_PROTOTYPE = Promise.prototype;
const deepProxyHandlers = {
    get: function(target, name, _receiver) {
        switch(name){
            case "$$typeof":
                return target.$$typeof;
            case "$$id":
                return target.$$id;
            case "$$async":
                return target.$$async;
            case "name":
                return target.name;
            case "displayName":
                return undefined;
            case "defaultProps":
                return undefined;
            case "toJSON":
                return undefined;
            case Symbol.toPrimitive.toString():
                return Object.prototype[Symbol.toPrimitive];
            case "Provider":
                throw new Error(`Cannot render a Client Context Provider on the Server. ` + `Instead, you can export a Client Component wrapper ` + `that itself renders a Client Context Provider.`);
            default:
                break;
        }
        const expression = String(target.name) + "." + String(name);
        throw new Error(`Cannot access ${expression} on the server. ` + "You cannot dot into a client module from a server component. " + "You can only pass the imported name through.");
    },
    set: function() {
        throw new Error("Cannot assign to a client module from a server module.");
    }
};
const proxyHandlers = {
    get: function(target, name, _receiver) {
        switch(name){
            case "$$typeof":
                return target.$$typeof;
            case "$$id":
                return target.$$id;
            case "$$async":
                return target.$$async;
            case "name":
                return target.name;
            case "defaultProps":
                return undefined;
            case "toJSON":
                return undefined;
            case Symbol.toPrimitive.toString():
                return Object.prototype[Symbol.toPrimitive];
            case "__esModule":
                const moduleId = target.$$id;
                target.default = Object.defineProperties(function() {
                    throw new Error(`Attempted to call the default export of ${moduleId} from the server ` + `but it's on the client. It's not possible to invoke a client function from ` + `the server, it can only be rendered as a Component or passed to props of a ` + `Client Component.`);
                }, {
                    $$typeof: {
                        value: CLIENT_REFERENCE
                    },
                    $$id: {
                        value: target.$$id + "#"
                    },
                    $$async: {
                        value: target.$$async
                    }
                });
                return true;
            case "then":
                if (target.then) {
                    return target.then;
                }
                if (!target.$$async) {
                    const clientReference = Object.defineProperties({}, {
                        $$typeof: {
                            value: CLIENT_REFERENCE
                        },
                        $$id: {
                            value: target.$$id
                        },
                        $$async: {
                            value: true
                        }
                    });
                    const proxy = new Proxy(clientReference, proxyHandlers);
                    target.status = "fulfilled";
                    target.value = proxy;
                    const then = target.then = Object.defineProperties(function then(resolve, _reject) {
                        return Promise.resolve(resolve(proxy));
                    }, {
                        $$typeof: {
                            value: CLIENT_REFERENCE
                        },
                        $$id: {
                            value: target.$$id
                        },
                        $$async: {
                            value: false
                        }
                    });
                    return then;
                } else {
                    return undefined;
                }
            default:
                break;
        }
        let cachedReference = target[name];
        if (!cachedReference) {
            const reference = Object.defineProperties(function() {
                throw new Error(`Attempted to call ${String(name)}() from the server but ${String(name)} is on the client. ` + `It's not possible to invoke a client function from the server, it can ` + `only be rendered as a Component or passed to props of a Client Component.`);
            }, {
                $$typeof: {
                    value: CLIENT_REFERENCE
                },
                $$id: {
                    value: target.$$id + "#" + name
                },
                $$async: {
                    value: target.$$async
                }
            });
            cachedReference = target[name] = new Proxy(reference, deepProxyHandlers);
        }
        return cachedReference;
    },
    getPrototypeOf (_target) {
        return PROMISE_PROTOTYPE;
    },
    set: function() {
        throw new Error("Cannot assign to a client module from a server module.");
    }
};
function createProxy(moduleId) {
    const clientReference = Object.defineProperties({}, {
        $$typeof: {
            value: CLIENT_REFERENCE
        },
        $$id: {
            value: moduleId
        },
        $$async: {
            value: false
        }
    });
    return new Proxy(clientReference, proxyHandlers);
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/rsc/preloads.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    preloadStyle: null,
    preloadFont: null,
    preconnect: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    preloadStyle: function() {
        return preloadStyle;
    },
    preloadFont: function() {
        return preloadFont;
    },
    preconnect: function() {
        return preconnect;
    }
});
const _reactdom = _interop_require_default(__turbopack_require__("[project]/node_modules/next/dist/compiled/react-dom/server-rendering-stub.js (ecmascript, rsc)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const stylePreloadOptions = {
    as: "style"
};
function preloadStyle(href) {
    _reactdom.default.preload(href, stylePreloadOptions);
}
function preloadFont(href, type) {
    _reactdom.default.preload(href, {
        as: "font",
        type
    });
}
function preconnect(href, crossOrigin) {
    if (typeof crossOrigin === "string") {
        _reactdom.default.preconnect(href, {
            crossOrigin
        });
    } else {
        _reactdom.default.preconnect(href);
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/entry-base.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppRouter: null,
    LayoutRouter: null,
    RenderFromTemplateContext: null,
    staticGenerationAsyncStorage: null,
    requestAsyncStorage: null,
    actionAsyncStorage: null,
    staticGenerationBailout: null,
    createSearchParamsBailoutProxy: null,
    serverHooks: null,
    renderToReadableStream: null,
    decodeReply: null,
    decodeAction: null,
    preloadStyle: null,
    preloadFont: null,
    preconnect: null,
    StaticGenerationSearchParamsBailoutProvider: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppRouter: function() {
        return AppRouter;
    },
    LayoutRouter: function() {
        return LayoutRouter;
    },
    RenderFromTemplateContext: function() {
        return RenderFromTemplateContext;
    },
    staticGenerationAsyncStorage: function() {
        return staticGenerationAsyncStorage;
    },
    requestAsyncStorage: function() {
        return requestAsyncStorage;
    },
    actionAsyncStorage: function() {
        return actionAsyncStorage;
    },
    staticGenerationBailout: function() {
        return staticGenerationBailout;
    },
    createSearchParamsBailoutProxy: function() {
        return createSearchParamsBailoutProxy;
    },
    serverHooks: function() {
        return serverHooks;
    },
    renderToReadableStream: function() {
        return renderToReadableStream;
    },
    decodeReply: function() {
        return decodeReply;
    },
    decodeAction: function() {
        return decodeAction;
    },
    preloadStyle: function() {
        return preloadStyle;
    },
    preloadFont: function() {
        return preloadFont;
    },
    preconnect: function() {
        return preconnect;
    },
    StaticGenerationSearchParamsBailoutProvider: function() {
        return StaticGenerationSearchParamsBailoutProvider;
    }
});
const { default: AppRouter } = __turbopack_require__("[project]/node_modules/next/dist/client/components/app-router.js (ecmascript, rsc)");
const { default: LayoutRouter } = __turbopack_require__("[project]/node_modules/next/dist/client/components/layout-router.js (ecmascript, rsc)");
const { default: RenderFromTemplateContext } = __turbopack_require__("[project]/node_modules/next/dist/client/components/render-from-template-context.js (ecmascript, rsc)");
const { staticGenerationAsyncStorage } = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-async-storage.js (ecmascript, rsc)");
const { requestAsyncStorage } = __turbopack_require__("[project]/node_modules/next/dist/client/components/request-async-storage.js (ecmascript, rsc)");
const { actionAsyncStorage } = __turbopack_require__("[project]/node_modules/next/dist/client/components/action-async-storage.js (ecmascript, rsc)");
const { staticGenerationBailout } = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-bailout.js (ecmascript, rsc)");
const { default: StaticGenerationSearchParamsBailoutProvider } = __turbopack_require__("[project]/node_modules/next/dist/client/components/static-generation-searchparams-bailout-provider.js (ecmascript, rsc)");
const { createSearchParamsBailoutProxy } = __turbopack_require__("[project]/node_modules/next/dist/client/components/searchparams-bailout-proxy.js (ecmascript, rsc)");
const serverHooks = __turbopack_require__("[project]/node_modules/next/dist/client/components/hooks-server-context.js (ecmascript, rsc)");
const { renderToReadableStream, decodeReply, decodeAction } = __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-webpack/server.edge.js (ecmascript, rsc)");
const { preloadStyle, preloadFont, preconnect } = __turbopack_require__("[project]/node_modules/next/dist/server/app-render/rsc/preloads.js (ecmascript, rsc)");

}.call(this) }),
"[project]/node_modules/next/dist/server/app-render/entry-base.js (ecmascript, client chunks, rsc)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname }) => (() => {

__turbopack_esm__({
    default: () => __turbopack_import__("[project]/node_modules/next/dist/server/app-render/entry-base.js (ecmascript, rsc)"),
    chunks: () => chunks,
});
const chunks = [];

})()),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReflectAdapter", {
    enumerable: true,
    get: function() {
        return ReflectAdapter;
    }
});
class ReflectAdapter {
    static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === "function") {
            return value.bind(target);
        }
        return value;
    }
    static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
    }
    static has(target, prop) {
        return Reflect.has(target, prop);
    }
    static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/headers.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyHeadersError: null,
    HeadersAdapter: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyHeadersError: function() {
        return ReadonlyHeadersError;
    },
    HeadersAdapter: function() {
        return HeadersAdapter;
    }
});
const _reflect = __turbopack_require__("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js (ecmascript, rsc)");
class ReadonlyHeadersError extends Error {
    constructor(){
        super("Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers");
    }
    static callable() {
        throw new ReadonlyHeadersError();
    }
}
class HeadersAdapter extends Headers {
    constructor(headers){
        super();
        this.headers = new Proxy(headers, {
            get (target, prop, receiver) {
                if (typeof prop === "symbol") {
                    return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
                const lowercased = prop.toLowerCase();
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                if (typeof original === "undefined") return;
                return _reflect.ReflectAdapter.get(target, original, receiver);
            },
            set (target, prop, value, receiver) {
                if (typeof prop === "symbol") {
                    return _reflect.ReflectAdapter.set(target, prop, value, receiver);
                }
                const lowercased = prop.toLowerCase();
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                return _reflect.ReflectAdapter.set(target, original ?? prop, value, receiver);
            },
            has (target, prop) {
                if (typeof prop === "symbol") return _reflect.ReflectAdapter.has(target, prop);
                const lowercased = prop.toLowerCase();
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                if (typeof original === "undefined") return false;
                return _reflect.ReflectAdapter.has(target, original);
            },
            deleteProperty (target, prop) {
                if (typeof prop === "symbol") return _reflect.ReflectAdapter.deleteProperty(target, prop);
                const lowercased = prop.toLowerCase();
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                if (typeof original === "undefined") return true;
                return _reflect.ReflectAdapter.deleteProperty(target, original);
            }
        });
    }
    static seal(headers) {
        return new Proxy(headers, {
            get (target, prop, receiver) {
                switch(prop){
                    case "append":
                    case "delete":
                    case "set":
                        return ReadonlyHeadersError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
    merge(value) {
        if (Array.isArray(value)) return value.join(", ");
        return value;
    }
    static from(headers) {
        if (headers instanceof Headers) return headers;
        return new HeadersAdapter(headers);
    }
    append(name, value) {
        const existing = this.headers[name];
        if (typeof existing === "string") {
            this.headers[name] = [
                existing,
                value
            ];
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            this.headers[name] = value;
        }
    }
    delete(name) {
        delete this.headers[name];
    }
    get(name) {
        const value = this.headers[name];
        if (typeof value !== "undefined") return this.merge(value);
        return null;
    }
    has(name) {
        return typeof this.headers[name] !== "undefined";
    }
    set(name, value) {
        this.headers[name] = value;
    }
    forEach(callbackfn, thisArg) {
        for (const [name, value] of this.entries()){
            callbackfn.call(thisArg, value, name, this);
        }
    }
    *entries() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            const value = this.get(name);
            yield [
                name,
                value
            ];
        }
    }
    *keys() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            yield name;
        }
    }
    *values() {
        for (const key of Object.keys(this.headers)){
            const value = this.get(key);
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}

}.call(this) }),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js (ecmascript, rsc)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ReadonlyRequestCookiesError: null,
    RequestCookiesAdapter: null,
    getModifiedCookieValues: null,
    appendMutableCookies: null,
    MutableRequestCookiesAdapter: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyRequestCookiesError: function() {
        return ReadonlyRequestCookiesError;
    },
    RequestCookiesAdapter: function() {
        return RequestCookiesAdapter;
    },
    getModifiedCookieValues: function() {
        return getModifiedCookieValues;
    },
    appendMutableCookies: function() {
        return appendMutableCookies;
    },
    MutableRequestCookiesAdapter: function() {
        return MutableRequestCookiesAdapter;
    }
});
const _cookies = __turbopack_require__("[project]/node_modules/next/dist/server/web/spec-extension/cookies.js (ecmascript, rsc)");
const _reflect = __turbopack_require__("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js (ecmascript, rsc)");
class ReadonlyRequestCookiesError extends Error {
    constructor(){
        super("Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#cookiessetname-value-options");
    }
    static callable() {
        throw new ReadonlyRequestCookiesError();
    }
}
class RequestCookiesAdapter {
    static seal(cookies) {
        return new Proxy(cookies, {
            get (target, prop, receiver) {
                switch(prop){
                    case "clear":
                    case "delete":
                    case "set":
                        return ReadonlyRequestCookiesError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
}
const SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for("next.mutated.cookies");
function getModifiedCookieValues(cookies) {
    const modified = cookies[SYMBOL_MODIFY_COOKIE_VALUES];
    if (!modified || !Array.isArray(modified) || modified.length === 0) {
        return [];
    }
    return modified;
}
function appendMutableCookies(headers, mutableCookies) {
    const modifiedCookieValues = getModifiedCookieValues(mutableCookies);
    if (modifiedCookieValues.length === 0) {
        return false;
    }
    const resCookies = new _cookies.ResponseCookies(headers);
    const returnedCookies = resCookies.getAll();
    for (const cookie of modifiedCookieValues){
        resCookies.set(cookie);
    }
    for (const cookie of returnedCookies){
        resCookies.set(cookie);
    }
    return true;
}
class MutableRequestCookiesAdapter {
    static wrap(cookies, res) {
        const responseCookes = new _cookies.ResponseCookies(new Headers());
        for (const cookie of cookies.getAll()){
            responseCookes.set(cookie);
        }
        let modifiedValues = [];
        const modifiedCookies = new Set();
        const updateResponseCookies = ()=>{
            var _fetch___nextGetStaticStore;
            const staticGenerationAsyncStore = fetch.__nextGetStaticStore == null ? void 0 : (_fetch___nextGetStaticStore = fetch.__nextGetStaticStore()) == null ? void 0 : _fetch___nextGetStaticStore.getStore();
            if (staticGenerationAsyncStore) {
                staticGenerationAsyncStore.pathWasRevalidated = true;
            }
            const allCookies = responseCookes.getAll();
            modifiedValues = allCookies.filter((c)=>modifiedCookies.has(c.name));
            if (res) {
                const serializedCookies = [];
                for (const cookie of modifiedValues){
                    const tempCookies = new _cookies.ResponseCookies(new Headers());
                    tempCookies.set(cookie);
                    serializedCookies.push(tempCookies.toString());
                }
                res.setHeader("Set-Cookie", serializedCookies);
            }
        };
        return new Proxy(responseCookes, {
            get (target, prop, receiver) {
                switch(prop){
                    case SYMBOL_MODIFY_COOKIE_VALUES:
                        return modifiedValues;
                    case "delete":
                        return function(...args) {
                            modifiedCookies.add(typeof args[0] === "string" ? args[0] : args[0].name);
                            try {
                                target.delete(...args);
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    case "set":
                        return function(...args) {
                            modifiedCookies.add(typeof args[0] === "string" ? args[0] : args[0].name);
                            try {
                                return target.set(...args);
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
}

}.call(this) }),
}]);

//# sourceMappingURL=node_modules_7537f4._.js.map